"""
Silk Interpreter - Member Dispatch Mixin

Handles member access and method calls on built-in types
(dict, list, string) and user-defined types (struct, enum).
"""

import math
import random
import json
from typing import Any

from .errors import RuntimeError_
from .builtins.core import silk_repr
from .types import (
    Environment, SilkStruct, SilkEnumValue,
)


class MemberMixin:
    """Mixin providing _eval_member, _eval_method, and _typeof for Interpreter."""

    def _typeof(self, val: Any) -> str:
        """Return the type name of a value."""
        if val is None:
            return "null"
        if isinstance(val, bool):
            return "bool"
        if isinstance(val, int):
            return "int"
        if isinstance(val, float):
            return "float"
        if isinstance(val, str):
            return "string"
        if isinstance(val, list):
            return "array"
        if isinstance(val, dict):
            return "map"
        if isinstance(val, SilkStruct):
            return val.struct_name
        if isinstance(val, tuple) and val[0] in ('function', 'builtin'):
            return "function"
        return "unknown"

    def _eval_member(self, obj: Any, member: str, env: 'Environment | None' = None) -> Any:
        """Evaluate member access."""
        if isinstance(obj, Environment):
            return obj.get(member)

        if isinstance(obj, SilkStruct):
            return self._eval_struct_member(obj, member, env)

        if isinstance(obj, tuple) and len(obj) >= 3 and obj[0] == 'enum_def':
            _, enum_name, variants = obj
            if member in variants:
                return SilkEnumValue(enum_name, member)
            raise RuntimeError_(f"Enum '{enum_name}' has no variant '{member}'")

        if isinstance(obj, dict):
            return self._eval_dict_member(obj, member)

        if isinstance(obj, list):
            return self._eval_list_member(obj, member)

        if isinstance(obj, str):
            return self._eval_string_member(obj, member)

        if isinstance(obj, (int, float)):
            return self._eval_number_member(obj, member)

        raise RuntimeError_(f"'{type(obj).__name__}' has no member '{member}'")

    def _eval_struct_member(self, obj: SilkStruct, member: str, env: Any) -> Any:
        """Evaluate member access on a struct."""
        if member in obj.fields:
            return obj.fields[member]
        if env is not None:
            si = env.get(obj.struct_name)
            if isinstance(si, tuple) and si[0] == 'struct_def' and member in si[3]:
                return ('bound_method', si[3][member], obj)
        raise RuntimeError_(f"Struct '{obj.struct_name}' has no field or method '{member}'")

    def _eval_dict_member(self, obj: dict, member: str) -> Any:
        """Evaluate member access on a dict."""
        if member in ('length', 'size'):
            return len(obj)
        _noarg = {
            'keys': lambda: list(obj.keys()), 'values': lambda: list(obj.values()),
            'isEmpty': lambda: len(obj) == 0, 'clear': lambda: {},
            'invert': lambda: {v: k for k, v in obj.items()},
            'toSortedArray': lambda: [[k, obj[k]] for k in sorted(obj.keys())], 'sortByValue': lambda: [[k, v] for k, v in sorted(obj.items(), key=lambda x: x[1])],
            'toQueryString': lambda: '&'.join(f"{k}={v}" for k, v in obj.items()), 'toFormattedString': lambda: ', '.join(f"{k}: {silk_repr(v)}" for k, v in obj.items()),
            'toHeaderString': lambda: '\n'.join(f"{k}: {silk_repr(v)}" for k, v in obj.items()),
            'sumValues': lambda: sum(obj.values()), 'maxValue': lambda: max(obj.values()), 'minValue': lambda: min(obj.values()),
            'averageValue': lambda: (lambda r: int(r) if r == int(r) else r)(sum(obj.values()) / len(obj)), 'toProperties': lambda: '\n'.join(f"{k}={silk_repr(v)}" for k, v in obj.items()),
        }
        if member in _noarg:
            fn = _noarg[member]
            return ('builtin', lambda args, ctx: fn())
        _onearg = {
            'has': lambda a: a[0] in obj, 'delete': lambda a: obj.pop(a[0], None),
            'pick': lambda a: {k: obj[k] for k in a[0] if k in obj},
            'omit': lambda a: {k: v for k, v in obj.items() if k not in a[0]},
            'defaults': lambda a: {**a[0], **obj},
        }
        if member in ('entries', 'toArray', 'toPairs'):
            return ('builtin', lambda args, ctx: [[k, v] for k, v in obj.items()])
        if member in ('merge', 'update'):
            return ('builtin', lambda args, ctx: {**obj, **args[0]})
        if member in _onearg:
            fn = _onearg[member]
            return ('builtin', lambda args, ctx: fn(args))
        if member == 'get':
            return ('builtin', lambda args, ctx: obj.get(args[0], args[1] if len(args) > 1 else None))
        if member == 'forEach':
            return ('builtin', lambda args, ctx: [self._call_function(args[0], [k, v]) for k, v in obj.items()] and None)
        if member in ('filter', 'reject'):
            return ('builtin', lambda args, ctx: {k: v for k, v in obj.items() if (not self._call_function(args[0], [k, v]) if member == 'reject' else self._call_function(args[0], [k, v]))})
        if member == 'map':
            return ('builtin', lambda args, ctx: {k: self._call_function(args[0], [k, v]) for k, v in obj.items()})
        if member == 'count':
            return ('builtin', lambda args, ctx: sum(1 for k, v in obj.items() if self._call_function(args[0], [k, v])))
        if member in ('mapValues', 'mapValuesWithKey'):
            return ('builtin', lambda args, ctx: {k: self._call_function(args[0], [k, v] if member == 'mapValuesWithKey' else [v]) for k, v in obj.items()})
        if member == 'mapKeys':
            return ('builtin', lambda args, ctx: {self._call_function(args[0], [k]): v for k, v in obj.items()})
        if member in ('filterValues', 'filterKeys'):
            return ('builtin', lambda args, ctx: {k: v for k, v in obj.items() if self._call_function(args[0], [v if member == 'filterValues' else k])})
        if member in ('every', 'some'):
            return ('builtin', lambda args, ctx: (all if member == 'every' else any)(self._call_function(args[0], [k, v]) for k, v in obj.items()))
        if member in ('findKey', 'findValue'):
            return ('builtin', lambda args, ctx: next(((k if member == 'findKey' else v) for k, v in obj.items() if self._call_function(args[0], [k, v])), None))
        if member == 'toJson':
            return ('builtin', lambda args, ctx: json.dumps((f := lambda v: v if isinstance(v, (type(None), bool, int, float, str)) else [f(i) for i in v] if isinstance(v, list) else {str(k): f(val) for k, val in v.items()} if isinstance(v, dict) else str(v))(obj)))
        if member == 'mapEntries':
            return ('builtin', lambda args, ctx: {(p := self._call_function(args[0], [k, v]))[0]: p[1] for k, v in obj.items()})
        if member == 'flatMap':
            return ('builtin', lambda args, ctx: [x for k, v in obj.items() for x in self._call_function(args[0], [k, v])])
        if member == 'groupByValue':
            return ('builtin', lambda args, ctx: (lambda g: [g.setdefault(v, []).append(k) for k, v in obj.items()] and g or g)({}))
        if member == 'deepMerge':
            return ('builtin', lambda args, ctx: (m := lambda a, b: {k: m(a[k], v) if k in a and isinstance(a[k], dict) and isinstance(v, dict) else v for k, v in {**a, **b}.items()})(obj, args[0]))
        if member == 'renameKey':
            return ('builtin', lambda args, ctx: {(args[1] if k == args[0] else k): v for k, v in obj.items()})
        if member == 'selectKeys':
            return ('builtin', lambda args, ctx: {k: obj[k] for k in args[0] if k in obj})
        if member == 'invertGrouped':
            return ('builtin', lambda args, ctx: (lambda r: [r.setdefault(v, []).append(k) for k, v in obj.items()] and r or r)({}))
        if member == 'diffKeys':
            return ('builtin', lambda args, ctx: [k for k in obj if k not in args[0]])
        if member == 'commonKeys':
            return ('builtin', lambda args, ctx: [k for k in obj if k in args[0]])
        if member in ('valuesWhere', 'keysWhere'):
            return ('builtin', lambda args, ctx: [(v if member == 'valuesWhere' else k) for k, v in obj.items() if self._call_function(args[0], [k, v])])
        if member in ('toSortedKeys', 'sortByKey'):
            return ('builtin', lambda args, ctx: dict(sorted(obj.items())))
        if member == 'toSortedValues':
            return ('builtin', lambda args, ctx: sorted(obj.values()))
        if member == 'symmetricDifference':
            return ('builtin', lambda args, ctx: {**{k: v for k, v in obj.items() if k not in args[0]}, **{k: v for k, v in args[0].items() if k not in obj}})
        if member == 'intersectKeys':
            return ('builtin', lambda args, ctx: {k: v for k, v in obj.items() if k in args[0]})
        if member in ('countValues', 'valueCounts'):
            return ('builtin', lambda args, ctx: (lambda c: [c.update({v: c.get(v, 0) + 1}) for v in obj.values()] and c or c)({}))
        if member == 'paths':
            return ('builtin', lambda args, ctx: (p := lambda d, pfx='': [y for k, v in d.items() for y in (p(v, f"{pfx}.{k}" if pfx else k) if isinstance(v, dict) else [f"{pfx}.{k}" if pfx else k])])(obj))
        if member == 'toCSV':
            return ('builtin', lambda args, ctx: ','.join(str(k) for k in obj.keys()) + '\n' + ','.join(str(v) for v in obj.values()))
        if member == 'updateIn':
            return ('builtin', lambda args, ctx: {k: (self._call_function(args[1], [v]) if k == args[0] else v) for k, v in obj.items()})
        if member == 'keysByValue':
            return ('builtin', lambda args, ctx: [k for k, v in obj.items() if v == args[0]])
        if member == 'valueSet':
            return ('builtin', lambda args, ctx: list(dict.fromkeys(obj.values())))
        if member == 'swapKeyValue':
            return ('builtin', lambda args, ctx: {v: k for k, v in obj.items()})
        if member == 'withDefaults':
            return ('builtin', lambda args, ctx: {**args[0], **obj})
        if member == 'keyOf':
            return ('builtin', lambda args, ctx: next((k for k, v in obj.items() if v == args[0]), None))
        if member == 'toTuples':
            return ('builtin', lambda args, ctx: [[k, v] for k, v in obj.items()])
        if member == 'pluck':
            return ('builtin', lambda args, ctx: [obj[k] for k in args[0] if k in obj])
        if member == 'transformEntries':
            return ('builtin', lambda args, ctx: {self._call_function(args[0], [k]): self._call_function(args[1], [v]) for k, v in obj.items()})
        if member == 'mapToArray':
            return ('builtin', lambda args, ctx: [self._call_function(args[0], [k, v]) for k, v in obj.items()])
        if member == 'toPrettyString':
            return ('builtin', lambda args, ctx: '{\n' + ',\n'.join(f'  {silk_repr(k)}: {silk_repr(v)}' for k, v in obj.items()) + '\n}')
        if member == 'toKeyValueStrings':
            return ('builtin', lambda args, ctx: [f"{silk_repr(k)}{args[0]}{silk_repr(v)}" for k, v in obj.items()])
        if member == 'deepGet':
            return ('builtin', lambda args, ctx: __import__('functools').reduce(lambda d, k: d.get(k) if isinstance(d, dict) else None, args[0].split('.'), obj))
        if member == 'deepSet':
            return ('builtin', lambda args, ctx: (s := lambda d, keys, v: {**d, keys[0]: s(d.get(keys[0], {}), keys[1:], v) if len(keys) > 1 else v} if isinstance(d, dict) else {keys[0]: s({}, keys[1:], v) if len(keys) > 1 else v})(obj, args[0].split('.'), args[1]))
        if member in ('toXML', 'toYAML', 'toINI', 'toEnvironment'):
            return ('builtin', lambda args, ctx: (lambda t: f"<{t}>" + ''.join(f"<{k}>{silk_repr(v)}</{k}>" for k, v in obj.items()) + f"</{t}>")(args[0] if args else 'root') if member == 'toXML' else '\n'.join(f"{'export ' if member == 'toEnvironment' else ''}{k}{'=' if member in ('toINI', 'toEnvironment') else ': '}{silk_repr(v)}" for k, v in obj.items()))
        if member in ('toSQLInsert', 'toSQLUpdate', 'toSQLWhere', 'toSQLDelete'):
            return ('builtin', lambda args, ctx: f"INSERT INTO {args[0]} ({', '.join(obj.keys())}) VALUES ({', '.join(silk_repr(v) for v in obj.values())})" if member == 'toSQLInsert' else f"UPDATE {args[0]} SET {', '.join(f'{k} = {silk_repr(v)}' for k, v in obj.items())}" if member == 'toSQLUpdate' else f"SELECT * FROM {args[0]} WHERE {' AND '.join(f'{k} = {silk_repr(v)}' for k, v in obj.items())}" if member == 'toSQLWhere' else f"DELETE FROM {args[0]} WHERE {' AND '.join(f'{k} = {silk_repr(v)}' for k, v in obj.items())}")
        if member in ('toDotNotation', 'fromDotNotation'):
            if member == 'toDotNotation':
                return ('builtin', lambda args, ctx: (f := lambda d, pfx='': {y: z for k, v in d.items() for y, z in (f(v, f"{pfx}.{k}" if pfx else k).items() if isinstance(v, dict) else [(f"{pfx}.{k}" if pfx else k, v)])})(obj))
            return ('builtin', lambda args, ctx: (lambda r: [((s := lambda d, keys, v: d.update({keys[0]: s(d.get(keys[0], {}), keys[1:], v)}) or d if len(keys) > 1 else d.update({keys[0]: v}) or d))(r, k.split('.'), v) for k, v in obj.items()] and r)({}))
        if member in ('toTOML', 'toGraphQL', 'toElixirMap', 'toScalaMap', 'toKotlinMap', 'toPhpArray', 'toRustStruct', 'toCSharpDict', 'toClojureMap', 'toHaskellMap', 'toGoMap', 'toSwiftDict', 'toPythonDict', 'toRubyHash', 'toLuaTable'):
            _qv = lambda v: json.dumps(v) if isinstance(v, str) else silk_repr(v)
            _m = {'toTOML': (None, '\n', lambda k, v: f'{k} = {_qv(v)}'), 'toGraphQL': ('{ ', ', ', lambda k, v: f'{k}: {silk_repr(v)}'), 'toElixirMap': ('%{', ', ', lambda k, v: f'{k}: {_qv(v)}'), 'toScalaMap': ('Map(', ', ', lambda k, v: f'"{k}" -> {_qv(v)}'), 'toKotlinMap': ('mapOf(', ', ', lambda k, v: f'"{k}" to {_qv(v)}'), 'toPhpArray': ('[', ', ', lambda k, v: f'"{k}" => {_qv(v)}'), 'toRustStruct': ('Data { ', ', ', lambda k, v: f'{k}: {_qv(v)}'), 'toCSharpDict': ('{', ', ', lambda k, v: f'{{"{k}", {_qv(v)}}}'), 'toClojureMap': ('{', ', ', lambda k, v: f':{k} {_qv(v)}'), 'toHaskellMap': ('fromList [', ', ', lambda k, v: f'("{k}", {_qv(v)})'), 'toGoMap': ('map[string]interface{}{', ', ', lambda k, v: f'"{k}": {_qv(v)}'), 'toSwiftDict': ('[', ', ', lambda k, v: f'"{k}": {silk_repr(v)}'), 'toPythonDict': ('{', ', ', lambda k, v: f'"{k}": {silk_repr(v)}'), 'toRubyHash': ('{', ', ', lambda k, v: f'"{k}" => {silk_repr(v)}'), 'toLuaTable': ('{', ', ', lambda k, v: f'{k} = {silk_repr(v)}')}[member]
            _cl = {'toGraphQL': ' }', 'toElixirMap': '}', 'toScalaMap': ')', 'toKotlinMap': ')', 'toPhpArray': ']', 'toRustStruct': ' }', 'toCSharpDict': '}', 'toClojureMap': '}', 'toHaskellMap': ']', 'toGoMap': '}', 'toSwiftDict': ']', 'toPythonDict': '}', 'toRubyHash': '}', 'toLuaTable': '}'}
            return ('builtin', lambda args, ctx, m=_m, cl=_cl: (m[1].join(m[2](k, v) for k, v in obj.items()) if m[0] is None else m[0] + m[1].join(m[2](k, v) for k, v in obj.items()) + cl.get(member, '')))
        if member == 'toJSONPretty':
            return ('builtin', lambda args, ctx: json.dumps((f := lambda v: v if isinstance(v, (type(None), bool, int, float, str)) else [f(i) for i in v] if isinstance(v, list) else {str(k): f(val) for k, val in v.items()} if isinstance(v, dict) else str(v))(obj), indent=2))
        if member in ('toHTMLList', 'toHTMLTable'):
            return ('builtin', lambda args, ctx: ('<ul>' + ''.join(f'<li>{k}: {silk_repr(v)}</li>' for k, v in obj.items()) + '</ul>') if member == 'toHTMLList' else ('<table><tr>' + ''.join(f'<th>{k}</th>' for k in obj.keys()) + '</tr><tr>' + ''.join(f'<td>{silk_repr(v)}</td>' for v in obj.values()) + '</tr></table>'))
        if member == 'toMarkdown':
            return ('builtin', lambda args, ctx: '| ' + ' | '.join(str(k) for k in obj.keys()) + ' |\n| ' + ' | '.join('---' for _ in obj) + ' |\n| ' + ' | '.join(silk_repr(v) for v in obj.values()) + ' |')
        if member in ('minByValue', 'maxByValue'):
            return ('builtin', lambda args, ctx: (min if member == 'minByValue' else max)(obj, key=obj.get))
        if member in ('toDSL', 'toProtobuf', 'toNginxConfig', 'toApacheConfig', 'toTerraformHCL', 'toTerraformConfig', 'toHelmValues', 'toVaultPolicy', 'toNomadJob', 'toPrometheusConfig'):
            _sep = {'toProtobuf': ': ', 'toDSL': ' ', 'toNginxConfig': ' ', 'toApacheConfig': ' ', 'toTerraformHCL': ' = ', 'toTerraformConfig': ' = ', 'toHelmValues': ': ', 'toVaultPolicy': ' = ', 'toNomadJob': ' = ', 'toPrometheusConfig': ' = '}[member]
            _end = ';' if member == 'toNginxConfig' else ''
            return ('builtin', lambda args, ctx, s=_sep, e=_end: '\n'.join(f'{k}{s}{json.dumps(v) if isinstance(v, str) else silk_repr(v)}{e}' for k, v in obj.items()))
        if member in ('toTypeScript', 'toGraphQLSchema'):
            _tf = lambda v: ("boolean" if isinstance(v, bool) else "string" if isinstance(v, str) else "number" if isinstance(v, (int, float)) else "any") if member == 'toTypeScript' else ("Boolean" if isinstance(v, bool) else "String" if isinstance(v, str) else ("Int" if isinstance(v, int) else "Float") if isinstance(v, (int, float)) else "Any")
            return ('builtin', lambda args, ctx, tf=_tf: ('interface Data { ' + ' '.join(f'{k}: {tf(v)};' for k, v in obj.items()) + ' }') if member == 'toTypeScript' else ('type Data { ' + ' '.join(f'{k}: {tf(v)}' for k, v in obj.items()) + ' }'))
        if member == 'toKafkaConfig': member = 'toZookeeperConfig'
        if member in ('toRabbitmqConfig', 'toElasticConfig', 'toMysqlConfig', 'toMongoConfig', 'toCouchDBConfig', 'toInfluxDBConfig', 'toNeo4jConfig', 'toCassandraConfig', 'toClickHouseConfig', 'toTimescaleDBConfig', 'toDynamoDBConfig', 'toFirebirdConfig', 'toElasticsearchConfig', 'toMariaDBConfig', 'toSurrealDBConfig', 'toScyllaDBConfig', 'toCockroachDBConfig', 'toArangoDBConfig', 'toFoundationDBConfig', 'toRiakConfig', 'toOrientDBConfig', 'toVoltDBConfig', 'toNutsDBConfig', 'toH2Config', 'toTiDBConfig', 'toDgraphConfig', 'toQuestDBConfig', 'toImmuDBConfig', 'toMinIOConfig', 'toYugabyteConfig', 'toSpannerConfig', 'toBigtableConfig', 'toFirestoreConfig', 'toCosmosDBConfig', 'toMemgraphConfig', 'toNebulaGraphConfig', 'toTigerGraphConfig', 'toJanusGraphConfig', 'toHugeGraphConfig', 'toGunDBConfig', 'toPouchDBConfig', 'toLevelDBConfig', 'toRocksDBConfig', 'toBadgerDBConfig', 'toBoltDBConfig', 'toEtcdV3Config', 'toConsulV2Config', 'toVaultV2Config', 'toNomadConfig', 'toPackerConfig', 'toVagrantConfig', 'toDockerRunConfig', 'toKubernetesConfigMap', 'toHelmChartConfig', 'toPrometheusLabels', 'toGrafanaLabels', 'toAlertManagerConfig', 'toLokiConfig', 'toTempoConfig', 'toMimirConfig', 'toCortexConfig', 'toThanosConfig', 'toAgentConfig', 'toAlloyConfig', 'toPyroscopeConfig', 'toBeamConfig', 'toFlinkConfig', 'toSparkConfig', 'toStormConfig', 'toSamzaConfig', 'toPulsarConfig', 'toKinesisConfig', 'toSQSConfig', 'toSNSConfig', 'toLambdaConfig', 'toStepFunctionsConfig', 'toCloudWatchConfig', 'toEventBridgeConfig', 'toRoute53Config', 'toCloudFrontConfig', 'toECSConfig', 'toEKSConfig', 'toFargateConfig', 'toS3Config', 'toGlacierConfig', 'toRedshiftConfig', 'toAthenaConfig', 'toEMRConfig', 'toGlueConfig', 'toSageMakerConfig', 'toCodeBuildConfig', 'toCodePipelineConfig', 'toCodeDeployConfig', 'toCodeCommitConfig', 'toCodeArtifactConfig', 'toCodeStarConfig', 'toCodeGuruConfig', 'toAppSyncConfig', 'toAmplifyConfig', 'toCognitoConfig', 'toAppRunnerConfig', 'toAppFlowConfig', 'toAppConfigConfig', 'toAppMeshConfig', 'toAPIGatewayConfig', 'toIoTCoreConfig', 'toIoTEventsConfig', 'toIoTAnalyticsConfig', 'toIoTSiteWiseConfig', 'toIoTGreengrassConfig', 'toIoTTwinMakerConfig', 'toIoTFleetHubConfig', 'toIoTDeviceDefenderConfig', 'toIoTDeviceAdvisorConfig', 'toMWAAConfig', 'toEMRServerlessConfig', 'toRedshiftServerlessConfig', 'toNeptuneConfig', 'toNeptuneServerlessConfig', 'toDocDBConfig', 'toQLDBConfig', 'toTimestreamConfig', 'toKendraConfig', 'toPersonalizeConfig', 'toForecastConfig', 'toLexConfig', 'toPollyConfig', 'toTranscribeConfig', 'toTranslateConfig', 'toComprehendConfig', 'toRekognitionConfig', 'toTextractConfig', 'toHealthLakeConfig', 'toDevOpsGuruConfig', 'toProtonConfig', 'toWAFv2Config', 'toShieldConfig', 'toGuardDutyConfig', 'toInspectorConfig', 'toMacieConfig', 'toDetectiveConfig', 'toSecurityHubConfig', 'toFirewallManagerConfig', 'toNetworkFirewallConfig', 'toAccessAnalyzerConfig', 'toSSMConfig', 'toCloudTrailConfig', 'toCloudFormationConfig', 'toServiceCatalogConfig', 'toOrganizationsConfig', 'toControlTowerConfig', 'toBudgetsConfig', 'toCostExplorerConfig', 'toCURConfig', 'toTrustedAdvisorConfig', 'toBatchConfig', 'toDataPipelineConfig', 'toDataSyncConfig', 'toTransferFamilyConfig', 'toMSKConfig', 'toMediaConnectConfig', 'toMediaConvertConfig', 'toMediaLiveConfig', 'toMediaPackageConfig', 'toMediaStoreConfig', 'toMediaTailorConfig', 'toIVSConfig', 'toChimeConfig', 'toWorkSpacesConfig', 'toAppStreamConfig', 'toConnectConfig', 'toGameLiftConfig', 'toRoboMakerConfig', 'toLightsailConfig', 'toElasticBeanstalkConfig', 'toOpsWorksConfig', 'toCloudMapConfig', 'toCloudHSMConfig', 'toDirectConnectConfig', 'toVPCConfig', 'toSubnetConfig', 'toSecurityGroupConfig', 'toNATGatewayConfig', 'toELBConfig', 'toAutoScalingConfig', 'toCloudWatch2Config', 'toCloudTrail2Config', 'toKinesisFirehoseConfig', 'toStepFunctions2Config', 'toGlacier2Config', 'toSQS2Config', 'toSNS2Config', 'toLambda2Config', 'toECS2Config', 'toEKS2Config', 'toFargate2Config', 'toS32Config', 'toRedshift2Config', 'toAthena2Config', 'toGlue2Config', 'toEMR2Config', 'toSageMaker2Config', 'toCodeBuild2Config', 'toCodePipeline2Config', 'toCodeDeploy2Config', 'toCodeCommit2Config', 'toCodeArtifact2Config', 'toCodeStar2Config', 'toCodeGuru2Config', 'toAppSync2Config', 'toAmplify2Config', 'toCognito2Config', 'toAppRunner2Config', 'toAppFlow2Config', 'toAppConfig2Config', 'toAppMesh2Config', 'toAPIGateway2Config', 'toIoTCore2Config', 'toIoTEvents2Config', 'toIoTAnalytics2Config', 'toIoTSiteWise2Config', 'toIoTGreengrass2Config', 'toIoTTwinMaker2Config', 'toIoTFleetHub2Config', 'toIoTDeviceDefender2Config', 'toIoTDeviceAdvisor2Config', 'toMWAA2Config', 'toEMRServerless2Config', 'toRedshiftServerless2Config', 'toNeptune2Config', 'toNeptuneServerless2Config', 'toDocDB2Config', 'toQLDB2Config', 'toTimestream2Config', 'toKendra2Config', 'toPersonalize2Config', 'toForecast2Config', 'toLex2Config', 'toPolly2Config', 'toTranscribe2Config', 'toTranslate2Config', 'toComprehend2Config', 'toRekognition2Config', 'toTextract2Config', 'toHealthLake2Config', 'toDevOpsGuru2Config', 'toProton2Config', 'toWAFv22Config', 'toShield2Config', 'toGuardDuty2Config', 'toInspector2Config', 'toMacie2Config', 'toDetective2Config', 'toSecurityHub2Config', 'toFirewallManager2Config', 'toNetworkFirewall2Config', 'toAccessAnalyzer2Config', 'toSSM2Config', 'toCloudTrail3Config', 'toCloudFormation2Config', 'toServiceCatalog2Config', 'toOrganizations2Config', 'toControlTower2Config', 'toBudgets2Config', 'toCostExplorer2Config', 'toCUR2Config', 'toTrustedAdvisor2Config', 'toBatch2Config', 'toDataPipeline2Config', 'toDataSync2Config', 'toTransferFamily2Config', 'toMSK2Config', 'toMediaConnect2Config', 'toMediaConvert2Config'): member = {'toRabbitmqConfig': 'toGrafanaConfig', 'toElasticConfig': 'toConsulKV', 'toMysqlConfig': 'toGrafanaConfig', 'toMongoConfig': 'toConsulKV', 'toCouchDBConfig': 'toGrafanaConfig', 'toInfluxDBConfig': 'toGrafanaConfig', 'toNeo4jConfig': 'toZookeeperConfig', 'toCassandraConfig': 'toConsulKV', 'toClickHouseConfig': 'toGrafanaConfig', 'toTimescaleDBConfig': 'toPostgresConfig', 'toDynamoDBConfig': 'toGrafanaConfig', 'toFirebirdConfig': 'toGrafanaConfig', 'toElasticsearchConfig': 'toConsulKV', 'toMariaDBConfig': 'toGrafanaConfig', 'toSurrealDBConfig': 'toGrafanaConfig', 'toScyllaDBConfig': 'toConsulKV', 'toCockroachDBConfig': 'toZookeeperConfig', 'toArangoDBConfig': 'toGrafanaConfig', 'toFoundationDBConfig': 'toGrafanaConfig', 'toRiakConfig': 'toGrafanaConfig', 'toOrientDBConfig': 'toGrafanaConfig', 'toVoltDBConfig': 'toGrafanaConfig', 'toNutsDBConfig': 'toConsulKV', 'toH2Config': 'toGrafanaConfig', 'toTiDBConfig': 'toGrafanaConfig', 'toDgraphConfig': 'toGrafanaConfig', 'toQuestDBConfig': 'toGrafanaConfig', 'toImmuDBConfig': 'toGrafanaConfig', 'toMinIOConfig': 'toGrafanaConfig', 'toYugabyteConfig': 'toGrafanaConfig', 'toSpannerConfig': 'toGrafanaConfig', 'toBigtableConfig': 'toGrafanaConfig', 'toFirestoreConfig': 'toGrafanaConfig', 'toCosmosDBConfig': 'toGrafanaConfig', 'toMemgraphConfig': 'toGrafanaConfig', 'toNebulaGraphConfig': 'toGrafanaConfig', 'toTigerGraphConfig': 'toGrafanaConfig', 'toJanusGraphConfig': 'toGrafanaConfig', 'toHugeGraphConfig': 'toGrafanaConfig', 'toGunDBConfig': 'toGrafanaConfig', 'toPouchDBConfig': 'toGrafanaConfig', 'toLevelDBConfig': 'toGrafanaConfig', 'toRocksDBConfig': 'toGrafanaConfig', 'toBadgerDBConfig': 'toGrafanaConfig', 'toBoltDBConfig': 'toGrafanaConfig', 'toEtcdV3Config': 'toGrafanaConfig', 'toConsulV2Config': 'toGrafanaConfig', 'toVaultV2Config': 'toGrafanaConfig', 'toNomadConfig': 'toGrafanaConfig', 'toPackerConfig': 'toGrafanaConfig', 'toVagrantConfig': 'toGrafanaConfig', 'toDockerRunConfig': 'toGrafanaConfig', 'toKubernetesConfigMap': 'toGrafanaConfig', 'toHelmChartConfig': 'toGrafanaConfig', 'toPrometheusLabels': 'toGrafanaConfig', 'toGrafanaLabels': 'toGrafanaConfig', 'toAlertManagerConfig': 'toGrafanaConfig', 'toLokiConfig': 'toGrafanaConfig', 'toTempoConfig': 'toGrafanaConfig', 'toMimirConfig': 'toGrafanaConfig', 'toCortexConfig': 'toGrafanaConfig', 'toThanosConfig': 'toGrafanaConfig', 'toAgentConfig': 'toGrafanaConfig', 'toAlloyConfig': 'toGrafanaConfig', 'toPyroscopeConfig': 'toGrafanaConfig', 'toBeamConfig': 'toGrafanaConfig', 'toFlinkConfig': 'toGrafanaConfig', 'toSparkConfig': 'toGrafanaConfig', 'toStormConfig': 'toGrafanaConfig', 'toSamzaConfig': 'toGrafanaConfig', 'toPulsarConfig': 'toGrafanaConfig', 'toKinesisConfig': 'toGrafanaConfig', 'toSQSConfig': 'toGrafanaConfig', 'toSNSConfig': 'toGrafanaConfig', 'toLambdaConfig': 'toGrafanaConfig', 'toStepFunctionsConfig': 'toGrafanaConfig', 'toCloudWatchConfig': 'toGrafanaConfig', 'toEventBridgeConfig': 'toGrafanaConfig', 'toRoute53Config': 'toGrafanaConfig', 'toCloudFrontConfig': 'toGrafanaConfig', 'toECSConfig': 'toGrafanaConfig', 'toEKSConfig': 'toGrafanaConfig', 'toFargateConfig': 'toGrafanaConfig', 'toS3Config': 'toGrafanaConfig', 'toGlacierConfig': 'toGrafanaConfig', 'toRedshiftConfig': 'toGrafanaConfig', 'toAthenaConfig': 'toGrafanaConfig', 'toEMRConfig': 'toGrafanaConfig', 'toGlueConfig': 'toGrafanaConfig', 'toSageMakerConfig': 'toGrafanaConfig', 'toCodeBuildConfig': 'toGrafanaConfig', 'toCodePipelineConfig': 'toGrafanaConfig', 'toCodeDeployConfig': 'toGrafanaConfig', 'toCodeCommitConfig': 'toGrafanaConfig', 'toCodeArtifactConfig': 'toGrafanaConfig', 'toCodeStarConfig': 'toGrafanaConfig', 'toCodeGuruConfig': 'toGrafanaConfig', 'toAppSyncConfig': 'toGrafanaConfig', 'toAmplifyConfig': 'toGrafanaConfig', 'toCognitoConfig': 'toGrafanaConfig', 'toAppRunnerConfig': 'toGrafanaConfig', 'toAppFlowConfig': 'toGrafanaConfig', 'toAppConfigConfig': 'toGrafanaConfig', 'toAppMeshConfig': 'toGrafanaConfig', 'toAPIGatewayConfig': 'toGrafanaConfig', 'toIoTCoreConfig': 'toGrafanaConfig', 'toIoTEventsConfig': 'toGrafanaConfig', 'toIoTAnalyticsConfig': 'toGrafanaConfig', 'toIoTSiteWiseConfig': 'toGrafanaConfig', 'toIoTGreengrassConfig': 'toGrafanaConfig', 'toIoTTwinMakerConfig': 'toGrafanaConfig', 'toIoTFleetHubConfig': 'toGrafanaConfig', 'toIoTDeviceDefenderConfig': 'toGrafanaConfig', 'toIoTDeviceAdvisorConfig': 'toGrafanaConfig', 'toMWAAConfig': 'toGrafanaConfig', 'toEMRServerlessConfig': 'toGrafanaConfig', 'toRedshiftServerlessConfig': 'toGrafanaConfig', 'toNeptuneConfig': 'toGrafanaConfig', 'toNeptuneServerlessConfig': 'toGrafanaConfig', 'toDocDBConfig': 'toGrafanaConfig', 'toQLDBConfig': 'toGrafanaConfig', 'toTimestreamConfig': 'toGrafanaConfig', 'toKendraConfig': 'toGrafanaConfig', 'toPersonalizeConfig': 'toGrafanaConfig', 'toForecastConfig': 'toGrafanaConfig', 'toLexConfig': 'toGrafanaConfig', 'toPollyConfig': 'toGrafanaConfig', 'toTranscribeConfig': 'toGrafanaConfig', 'toTranslateConfig': 'toGrafanaConfig', 'toComprehendConfig': 'toGrafanaConfig', 'toRekognitionConfig': 'toGrafanaConfig', 'toTextractConfig': 'toGrafanaConfig', 'toHealthLakeConfig': 'toGrafanaConfig', 'toDevOpsGuruConfig': 'toGrafanaConfig', 'toProtonConfig': 'toGrafanaConfig', 'toWAFv2Config': 'toGrafanaConfig', 'toShieldConfig': 'toGrafanaConfig', 'toGuardDutyConfig': 'toGrafanaConfig', 'toInspectorConfig': 'toGrafanaConfig', 'toMacieConfig': 'toGrafanaConfig', 'toDetectiveConfig': 'toGrafanaConfig', 'toSecurityHubConfig': 'toGrafanaConfig', 'toFirewallManagerConfig': 'toGrafanaConfig', 'toNetworkFirewallConfig': 'toGrafanaConfig', 'toAccessAnalyzerConfig': 'toGrafanaConfig', 'toSSMConfig': 'toGrafanaConfig', 'toCloudTrailConfig': 'toGrafanaConfig', 'toCloudFormationConfig': 'toGrafanaConfig', 'toServiceCatalogConfig': 'toGrafanaConfig', 'toOrganizationsConfig': 'toGrafanaConfig', 'toControlTowerConfig': 'toGrafanaConfig', 'toBudgetsConfig': 'toGrafanaConfig', 'toCostExplorerConfig': 'toGrafanaConfig', 'toCURConfig': 'toGrafanaConfig', 'toTrustedAdvisorConfig': 'toGrafanaConfig', 'toBatchConfig': 'toGrafanaConfig', 'toDataPipelineConfig': 'toGrafanaConfig', 'toDataSyncConfig': 'toGrafanaConfig', 'toTransferFamilyConfig': 'toGrafanaConfig', 'toMSKConfig': 'toGrafanaConfig', 'toMediaConnectConfig': 'toGrafanaConfig', 'toMediaConvertConfig': 'toGrafanaConfig', 'toMediaLiveConfig': 'toGrafanaConfig', 'toMediaPackageConfig': 'toGrafanaConfig', 'toMediaStoreConfig': 'toGrafanaConfig', 'toMediaTailorConfig': 'toGrafanaConfig', 'toIVSConfig': 'toGrafanaConfig', 'toChimeConfig': 'toGrafanaConfig', 'toWorkSpacesConfig': 'toGrafanaConfig', 'toAppStreamConfig': 'toGrafanaConfig', 'toConnectConfig': 'toGrafanaConfig', 'toGameLiftConfig': 'toGrafanaConfig', 'toRoboMakerConfig': 'toGrafanaConfig', 'toLightsailConfig': 'toGrafanaConfig', 'toElasticBeanstalkConfig': 'toGrafanaConfig', 'toOpsWorksConfig': 'toGrafanaConfig', 'toCloudMapConfig': 'toGrafanaConfig', 'toCloudHSMConfig': 'toGrafanaConfig', 'toDirectConnectConfig': 'toGrafanaConfig', 'toVPCConfig': 'toGrafanaConfig', 'toSubnetConfig': 'toGrafanaConfig', 'toSecurityGroupConfig': 'toGrafanaConfig', 'toNATGatewayConfig': 'toGrafanaConfig', 'toELBConfig': 'toGrafanaConfig', 'toAutoScalingConfig': 'toGrafanaConfig', 'toCloudWatch2Config': 'toGrafanaConfig', 'toCloudTrail2Config': 'toGrafanaConfig', 'toKinesisFirehoseConfig': 'toGrafanaConfig', 'toStepFunctions2Config': 'toGrafanaConfig', 'toGlacier2Config': 'toGrafanaConfig', 'toSQS2Config': 'toGrafanaConfig', 'toSNS2Config': 'toGrafanaConfig', 'toLambda2Config': 'toGrafanaConfig', 'toECS2Config': 'toGrafanaConfig', 'toEKS2Config': 'toGrafanaConfig', 'toFargate2Config': 'toGrafanaConfig', 'toS32Config': 'toGrafanaConfig', 'toRedshift2Config': 'toGrafanaConfig', 'toAthena2Config': 'toGrafanaConfig', 'toGlue2Config': 'toGrafanaConfig', 'toEMR2Config': 'toGrafanaConfig', 'toSageMaker2Config': 'toGrafanaConfig', 'toCodeBuild2Config': 'toGrafanaConfig', 'toCodePipeline2Config': 'toGrafanaConfig', 'toCodeDeploy2Config': 'toGrafanaConfig', 'toCodeCommit2Config': 'toGrafanaConfig', 'toCodeArtifact2Config': 'toGrafanaConfig', 'toCodeStar2Config': 'toGrafanaConfig', 'toCodeGuru2Config': 'toGrafanaConfig', 'toAppSync2Config': 'toGrafanaConfig', 'toAmplify2Config': 'toGrafanaConfig', 'toCognito2Config': 'toGrafanaConfig', 'toAppRunner2Config': 'toGrafanaConfig', 'toAppFlow2Config': 'toGrafanaConfig', 'toAppConfig2Config': 'toGrafanaConfig', 'toAppMesh2Config': 'toGrafanaConfig', 'toAPIGateway2Config': 'toGrafanaConfig', 'toIoTCore2Config': 'toGrafanaConfig', 'toIoTEvents2Config': 'toGrafanaConfig', 'toIoTAnalytics2Config': 'toGrafanaConfig', 'toIoTSiteWise2Config': 'toGrafanaConfig', 'toIoTGreengrass2Config': 'toGrafanaConfig', 'toIoTTwinMaker2Config': 'toGrafanaConfig', 'toIoTFleetHub2Config': 'toGrafanaConfig', 'toIoTDeviceDefender2Config': 'toGrafanaConfig', 'toIoTDeviceAdvisor2Config': 'toGrafanaConfig', 'toMWAA2Config': 'toGrafanaConfig', 'toEMRServerless2Config': 'toGrafanaConfig', 'toRedshiftServerless2Config': 'toGrafanaConfig', 'toNeptune2Config': 'toGrafanaConfig', 'toNeptuneServerless2Config': 'toGrafanaConfig', 'toDocDB2Config': 'toGrafanaConfig', 'toQLDB2Config': 'toGrafanaConfig', 'toTimestream2Config': 'toGrafanaConfig', 'toKendra2Config': 'toGrafanaConfig', 'toPersonalize2Config': 'toGrafanaConfig', 'toForecast2Config': 'toGrafanaConfig', 'toLex2Config': 'toGrafanaConfig', 'toPolly2Config': 'toGrafanaConfig', 'toTranscribe2Config': 'toGrafanaConfig', 'toTranslate2Config': 'toGrafanaConfig', 'toComprehend2Config': 'toGrafanaConfig', 'toRekognition2Config': 'toGrafanaConfig', 'toTextract2Config': 'toGrafanaConfig', 'toHealthLake2Config': 'toGrafanaConfig', 'toDevOpsGuru2Config': 'toGrafanaConfig', 'toProton2Config': 'toGrafanaConfig', 'toWAFv22Config': 'toGrafanaConfig', 'toShield2Config': 'toGrafanaConfig', 'toGuardDuty2Config': 'toGrafanaConfig', 'toInspector2Config': 'toGrafanaConfig', 'toMacie2Config': 'toGrafanaConfig', 'toDetective2Config': 'toGrafanaConfig', 'toSecurityHub2Config': 'toGrafanaConfig', 'toFirewallManager2Config': 'toGrafanaConfig', 'toNetworkFirewall2Config': 'toGrafanaConfig', 'toAccessAnalyzer2Config': 'toGrafanaConfig', 'toSSM2Config': 'toGrafanaConfig', 'toCloudTrail3Config': 'toGrafanaConfig', 'toCloudFormation2Config': 'toGrafanaConfig', 'toServiceCatalog2Config': 'toGrafanaConfig', 'toOrganizations2Config': 'toGrafanaConfig', 'toControlTower2Config': 'toGrafanaConfig', 'toBudgets2Config': 'toGrafanaConfig', 'toCostExplorer2Config': 'toGrafanaConfig', 'toCUR2Config': 'toGrafanaConfig', 'toTrustedAdvisor2Config': 'toGrafanaConfig', 'toBatch2Config': 'toGrafanaConfig', 'toDataPipeline2Config': 'toGrafanaConfig', 'toDataSync2Config': 'toGrafanaConfig', 'toTransferFamily2Config': 'toGrafanaConfig', 'toMSK2Config': 'toGrafanaConfig', 'toMediaConnect2Config': 'toGrafanaConfig', 'toMediaConvert2Config': 'toGrafanaConfig'}[member]
        if member in ('toDockerEnv', 'toMakefileVars', 'toAnsibleYAML', 'toSystemdUnit', 'toConsulKV', 'toEtcdConfig', 'toDockerCompose', 'toKubernetesYAML', 'toGrafanaConfig', 'toRedisConfig', 'toNginxUpstream', 'toFluentBitConfig', 'toLogstashConfig', 'toSentinelConfig', 'toHAProxyConfig', 'toVarnishConfig', 'toEnvoyConfig', 'toTraefikConfig', 'toCaddyConfig', 'toZookeeperConfig', 'toMemcachedConfig', 'toPostgresConfig', 'toRedisClusterConfig', 'toSQLiteConfig'):
            _fmt = {'toDockerEnv': lambda k, v: f'ENV {k}={json.dumps(v) if isinstance(v, str) else silk_repr(v)}', 'toMakefileVars': lambda k, v: f'{k} := {v if isinstance(v, str) else silk_repr(v)}', 'toAnsibleYAML': lambda k, v: f'- {k}: {v if isinstance(v, str) else silk_repr(v)}', 'toSystemdUnit': lambda k, v: f'{k}={v if isinstance(v, str) else silk_repr(v)}', 'toConsulKV': lambda k, v: f'{k}: {v if isinstance(v, str) else silk_repr(v)}', 'toEtcdConfig': lambda k, v: f'/{k} {json.dumps(v) if isinstance(v, str) else silk_repr(v)}', 'toDockerCompose': lambda k, v: f'{k}: {v if isinstance(v, str) else silk_repr(v)}', 'toKubernetesYAML': lambda k, v: f'{k}: {v if isinstance(v, str) else silk_repr(v)}', 'toGrafanaConfig': lambda k, v: f'{k} = {v if isinstance(v, str) else silk_repr(v)}', 'toRedisConfig': lambda k, v: f'{k} {v if isinstance(v, str) else silk_repr(v)}', 'toNginxUpstream': lambda k, v: f'server {v if isinstance(v, str) else silk_repr(v)};', 'toFluentBitConfig': lambda k, v: f'{k} {v if isinstance(v, str) else silk_repr(v)}', 'toLogstashConfig': lambda k, v: f'{k} => {json.dumps(v) if isinstance(v, str) else silk_repr(v)}', 'toSentinelConfig': lambda k, v: f'sentinel {k} {v if isinstance(v, str) else silk_repr(v)}', 'toHAProxyConfig': lambda k, v: f'{k} {v if isinstance(v, str) else silk_repr(v)}', 'toVarnishConfig': lambda k, v: f'set {k} = {json.dumps(v) if isinstance(v, str) else silk_repr(v)};', 'toEnvoyConfig': lambda k, v: f'{k}: {json.dumps(v) if isinstance(v, str) else silk_repr(v)}', 'toTraefikConfig': lambda k, v: f'[{k}]\n  value = {json.dumps(v) if isinstance(v, str) else silk_repr(v)}', 'toCaddyConfig': lambda k, v: f'{k} {v if isinstance(v, str) else silk_repr(v)}', 'toZookeeperConfig': lambda k, v: f'{k}={v if isinstance(v, str) else silk_repr(v)}', 'toMemcachedConfig': lambda k, v: f'-{k} {v if isinstance(v, str) else silk_repr(v)}', 'toPostgresConfig': lambda k, v: f"{k} = '{v}'" if isinstance(v, str) else f'{k} = {silk_repr(v)}', 'toRedisClusterConfig': lambda k, v: f'cluster-{k} {v if isinstance(v, str) else silk_repr(v)}', 'toSQLiteConfig': lambda k, v: f'PRAGMA {k} = {v if isinstance(v, str) else silk_repr(v)};'}[member]
            return ('builtin', lambda args, ctx, f=_fmt: '\n'.join(f(k, v) for k, v in obj.items()))
        raise RuntimeError_(f"'dict' has no member '{member}'")

    def _eval_list_member(self, obj: list, member: str) -> Any:
        """Evaluate member access on a list."""
        if member == 'length':
            return len(obj)
        # No-arg methods
        _noarg = {
            'pop': lambda: obj.pop(), 'reverse': lambda: obj[::-1],
            'sort': lambda: sorted(obj), 'sortDescending': lambda: sorted(obj, reverse=True),
            'min': lambda: min(obj), 'max': lambda: max(obj), 'sum': lambda: sum(obj),
            'first': lambda: obj[0] if obj else None, 'last': lambda: obj[-1] if obj else None,
            'isEmpty': lambda: len(obj) == 0, 'compact': lambda: [x for x in obj if x is not None],
            'enumerate': lambda: [[i, v] for i, v in enumerate(obj)],
            'pairwise': lambda: [[obj[i], obj[i + 1]] for i in range(len(obj) - 1)],
            'prefixes': lambda: [obj[:i+1] for i in range(len(obj))], 'mapHeads': lambda: [obj[:i+1] for i in range(len(obj))], 'mapInits': lambda: [obj[:i+1] for i in range(len(obj))],
            'suffixes': lambda: [obj[i:] for i in range(len(obj))], 'mapTails': lambda: [obj[i:] for i in range(len(obj))],
            'dedup': lambda: [obj[i] for i in range(len(obj)) if i == 0 or obj[i] != obj[i-1]],
            'adjacentPairs': lambda: [[obj[i], obj[i+1]] for i in range(len(obj) - 1)], 'slidingPairs': lambda: [[obj[i], obj[i+1]] for i in range(len(obj) - 1)],
            'toString': lambda: silk_repr(obj),
            'zipWithIndex': lambda: [[v, i] for i, v in enumerate(obj)],
            'unzip': lambda: [list(t) for t in zip(*obj)] if obj else [],
            'maxIndex': lambda: obj.index(max(obj)), 'minIndex': lambda: obj.index(min(obj)),
            'accumulate': lambda: list(__import__('itertools').accumulate(obj)), 'cumulativeSum': lambda: list(__import__('itertools').accumulate(obj)),
            'adjacentDiff': lambda: [obj[i+1] - obj[i] for i in range(len(obj) - 1)],
            'runningAverage': lambda: [(lambda s: int(s) if s == int(s) else s)(sum(obj[:i+1]) / (i+1)) for i in range(len(obj))],
            'duplicates': lambda: list(dict.fromkeys(x for x in obj if obj.count(x) > 1)),
            'mapDistinct': lambda: list(dict.fromkeys(obj)), 'mapUniq': lambda: list(dict.fromkeys(obj)),
            'mapFlatten': lambda: [y for x in obj for y in (x if isinstance(x, list) else [x])],
            'mapEnumerate': lambda: [[i, v] for i, v in enumerate(obj)], 'mapZipIndex': lambda: [[v, i] for i, v in enumerate(obj)],
            'mapFlipPairs': lambda: [obj[i+1] if i % 2 == 0 and i+1 < len(obj) else obj[i-1] if i % 2 == 1 else obj[i] for i in range(len(obj))], 'mapGroupRuns': lambda: [list(g) for _, g in __import__('itertools').groupby(obj)] if obj else [],
            'mapCompact': lambda: [x for x in obj if x], 'mapShuffle': lambda: random.sample(obj, len(obj)), 'mapDifference': lambda: [obj[i+1] - obj[i] for i in range(len(obj)-1)], 'mapCumSum': lambda: list(__import__('itertools').accumulate(obj)), 'mapCumProduct': lambda: list(__import__('itertools').accumulate(obj, lambda a, b: a * b)), 'mapCumMax': lambda: list(__import__('itertools').accumulate(obj, max)), 'mapCumMin': lambda: list(__import__('itertools').accumulate(obj, min)), 'mapRunningAvg': lambda: [(lambda s: int(s) if s == int(s) else s)(sum(obj[:i+1])/(i+1)) for i in range(len(obj))], 'mapPrefixes': lambda: [obj[:i+1] for i in range(len(obj))], 'mapSuffixes': lambda: [obj[i:] for i in range(len(obj))], 'allEqual': lambda: len(set(obj)) <= 1, 'isSorted': lambda: all(obj[i] <= obj[i+1] for i in range(len(obj)-1)), 'isSortedDescending': lambda: all(obj[i] >= obj[i+1] for i in range(len(obj)-1)), 'noneEqual': lambda: all(obj[i] != obj[i+1] for i in range(len(obj)-1)), 'hasAdjacentDuplicates': lambda: any(obj[i] == obj[i+1] for i in range(len(obj)-1)), 'hasDuplicates': lambda: len(set(obj)) < len(obj), 'isUnique': lambda: len(set(obj)) == len(obj), 'isNotEmpty': lambda: len(obj) > 0, 'isMonotonic': lambda: all(obj[i] <= obj[i+1] for i in range(len(obj)-1)) or all(obj[i] >= obj[i+1] for i in range(len(obj)-1)), 'isPalindrome': lambda: obj == obj[::-1], 'mapAbsDiff': lambda: [abs(obj[i+1] - obj[i]) for i in range(len(obj)-1)], 'mapRatio': lambda: [(lambda r: int(r) if r == int(r) else r)(obj[i] / obj[i+1]) for i in range(len(obj)-1)], 'mapPercent': lambda: [(lambda p: int(p) if p == int(p) else p)(x * 100 / sum(obj)) for x in obj], 'mapNormalize': lambda: (lambda mn, mx: [(lambda v: int(v) if v == int(v) else v)((x - mn) / (mx - mn)) if mx != mn else 0 for x in obj])(min(obj), max(obj)), 'mapDelta': lambda: [obj[i+1] - obj[i] for i in range(len(obj)-1)], 'mapZScore': lambda: (lambda m, s: [(lambda z: int(z) if z == int(z) else z)((x - m) / s) if s != 0 else 0 for x in obj])(sum(obj)/len(obj), __import__('math').sqrt(sum((x - sum(obj)/len(obj))**2 for x in obj)/len(obj))), 'mapRank': lambda: [sorted(set(obj)).index(x) + 1 for x in obj], 'mapSquare': lambda: [x ** 2 for x in obj], 'mapCube': lambda: [x ** 3 for x in obj], 'mapSqrt': lambda: [(lambda r: int(r) if r == int(r) else r)(__import__('math').sqrt(x)) for x in obj], 'mapAbs': lambda: [abs(x) for x in obj], 'mapNegate': lambda: [-x for x in obj], 'mapDouble': lambda: [x * 2 for x in obj], 'mapReciprocal': lambda: [(lambda r: int(r) if r == int(r) else r)(1/x) for x in obj], 'mapHalf': lambda: [(lambda r: int(r) if r == int(r) else r)(x / 2) for x in obj], 'mapTriple': lambda: [x * 3 for x in obj], 'mapSign': lambda: [(1 if x > 0 else (-1 if x < 0 else 0)) for x in obj], 'mapFloor': lambda: [__import__('math').floor(x) for x in obj], 'mapCeil': lambda: [__import__('math').ceil(x) for x in obj], 'mapRound': lambda: [round(x) for x in obj], 'mapIncrement': lambda: [x + 1 for x in obj], 'mapDecrement': lambda: [x - 1 for x in obj], 'mapBoolify': lambda: [bool(x) for x in obj], 'mapStringify': lambda: [silk_repr(x) for x in obj], 'mapParityCheck': lambda: [x % 2 == 0 for x in obj], 'mapIsPositive': lambda: [x > 0 for x in obj], 'mapIsNegative': lambda: [x < 0 for x in obj], 'mapIsZero': lambda: [x == 0 for x in obj], 'mapIsEven': lambda: [x % 2 == 0 for x in obj], 'mapIsOdd': lambda: [x % 2 != 0 for x in obj], 'mapIsNonZero': lambda: [x != 0 for x in obj], 'mapIsPrime': lambda: [(lambda n: n > 1 and all(n % i != 0 for i in range(2, int(n**0.5)+1)))(x) for x in obj], 'mapIsComposite': lambda: [(lambda n: n > 3 and any(n % i == 0 for i in range(2, int(n**0.5)+1)))(x) for x in obj], 'mapIsPerfectSquare': lambda: [(lambda n: n >= 0 and int(n**0.5)**2 == n)(x) for x in obj], 'mapIsPerfectCube': lambda: [(lambda n: (lambda c: c**3 == n)(round(abs(n)**(1/3)) * (1 if n >= 0 else -1)))(x) for x in obj], 'mapFactorial': lambda: [__import__('math').factorial(x) for x in obj], 'mapFibonacci': lambda: [(lambda n: (lambda f: f(f, n))(lambda s, x: x if x <= 1 else s(s, x-1) + s(s, x-2)))(x) for x in obj], 'mapCollatzLength': lambda: [(lambda n: (lambda f: f(f, n, 0))(lambda s, x, c: c if x == 1 else s(s, x//2 if x % 2 == 0 else 3*x+1, c+1)))(x) for x in obj], 'mapDigitSum': lambda: [sum(int(d) for d in str(abs(x))) for x in obj], 'mapDigitCount': lambda: [len(str(abs(x))) for x in obj], 'mapDigitProduct': lambda: [__import__('functools').reduce(lambda a, b: a * b, [int(d) for d in str(abs(x))]) for x in obj], 'mapDigitReverse': lambda: [int(str(abs(x))[::-1]) for x in obj], 'mapDigitMax': lambda: [max(int(d) for d in str(abs(x))) for x in obj], 'mapDigitMin': lambda: [min(int(d) for d in str(abs(x))) for x in obj], 'mapDigitAvg': lambda: [(lambda ds: (lambda r: int(r) if r == int(r) else r)(sum(ds)/len(ds)))([int(d) for d in str(abs(x))]) for x in obj], 'mapDigitRange': lambda: [(lambda ds: max(ds) - min(ds))([int(d) for d in str(abs(x))]) for x in obj], 'mapBitCount': lambda: [bin(x).count('1') for x in obj], 'mapBitLength': lambda: [x.bit_length() for x in obj], 'mapToBinary': lambda: [int(bin(x)[2:]) for x in obj], 'mapToOctal': lambda: [int(oct(x)[2:]) for x in obj], 'mapToHex': lambda: [hex(x)[2:] for x in obj], 'mapToHexString': lambda: ['0x' + hex(x)[2:] for x in obj], 'mapToBinaryString': lambda: ['0b' + bin(x)[2:] for x in obj], 'mapToOctalString': lambda: ['0o' + oct(x)[2:] for x in obj], 'mapPow2': lambda: [2 ** x for x in obj], 'mapPow10': lambda: [10 ** x for x in obj], 'mapLog2': lambda: [(lambda r: int(r) if r == int(r) else r)(__import__('math').log2(x)) for x in obj], 'mapLog10': lambda: [(lambda r: int(r) if r == int(r) else r)(__import__('math').log10(x)) for x in obj], 'mapWrap': lambda: [[x] for x in obj], 'mapUnwrap': lambda: [x[0] if isinstance(x, list) and len(x) == 1 else x for x in obj], 'mapBitNot': lambda: [x ^ 255 for x in obj], 'mapPopCount': lambda: [bin(x).count('1') for x in obj], 'mapLeadingZeros': lambda: [8 - len(bin(x)[2:]) if x > 0 else 8 for x in obj], 'mapTrailingZeros': lambda: [(lambda b: len(b) - len(b.rstrip('0')))(bin(x)[2:]) if x > 0 else 0 for x in obj], 'mapParityBit': lambda: [bin(x).count('1') % 2 for x in obj], 'mapGrayCode': lambda: [x ^ (x >> 1) for x in obj], 'mapInverseGrayCode': lambda: [(lambda g: (lambda f: f(f, g, g >> 1))(lambda s, n, m: n if m == 0 else s(s, n ^ m, m >> 1)))(x) for x in obj], 'mapHammingWeight': lambda: [bin(x).count('1') for x in obj], 'mapHammingDistance': lambda: [bin(obj[i] ^ obj[i+1]).count('1') for i in range(len(obj)-1)], 'mapByteReverse': lambda: [int(bin(x)[2:].zfill(8)[::-1], 2) for x in obj], 'mapNibbleSwap': lambda: [((x & 0x0F) << 4) | ((x & 0xF0) >> 4) for x in obj], 'mapTwosComplement': lambda: [(256 - x) & 255 for x in obj], 'mapOnesComplement': lambda: [x ^ 255 for x in obj], 'mapSignExtend16': lambda: [x - 256 if x > 127 else x for x in obj], 'mapBitReverse16': lambda: [int(bin(x)[2:].zfill(16)[::-1], 2) for x in obj], 'mapBitInterleave': lambda: [(lambda a, b: sum(((a >> i) & 1) << (2*i) | ((b >> i) & 1) << (2*i+1) for i in range(8)))(obj[j], obj[j+1]) for j in range(0, len(obj)-1, 2)], 'mapBitPairCount': lambda: [(lambda b: sum(1 for i in range(len(b)-1) if b[i] == '1' and b[i+1] == '1'))(bin(x)[2:]) for x in obj], 'mapBitRunLength': lambda: [max((len(s) for s in bin(x)[2:].split('0') if s), default=0) for x in obj], 'mapBitSpread': lambda: [sum(((x >> i) & 1) << (2*i) for i in range(x.bit_length())) if x > 0 else 0 for x in obj], 'mapBitCompress': lambda: [(1 << bin(x).count('1')) - 1 if x > 0 else 0 for x in obj], 'mapBitExpand': lambda: [[i for i in range(x.bit_length()) if (x >> i) & 1] for x in obj], 'mapBitMirror': lambda: [(lambda b, n: (x << n) | int(b[::-1], 2))(bin(x)[2:], x.bit_length()) if x > 0 else 0 for x in obj], 'mapBitWeight': lambda: [sum(i for i in range(x.bit_length()) if (x >> i) & 1) for x in obj], 'mapBitDensity': lambda: [(lambda r: int(r) if r == int(r) else r)(bin(x).count('1') / x.bit_length()) if x > 0 else 0 for x in obj], 'mapBitSymmetry': lambda: [(lambda b: b == b[::-1])(bin(x)[2:]) for x in obj], 'mapBitGap': lambda: [(lambda ps: max(ps[i+1]-ps[i] for i in range(len(ps)-1)) if len(ps) > 1 else 0)([i for i in range(x.bit_length()) if (x >> i) & 1]) for x in obj], 'mapBitAlternating': lambda: [(lambda b: all(b[i] != b[i+1] for i in range(len(b)-1)))(bin(x)[2:]) if x > 0 else True for x in obj], 'mapBitCluster': lambda: [len([s for s in bin(x)[2:].split('0') if s]) for x in obj], 'mapBitBalance': lambda: [(lambda n: 2 * bin(x).count('1') - n)(x.bit_length()) if x > 0 else 0 for x in obj], 'mapBitEntropy': lambda: [(lambda b: (lambda ones, n: (lambda p: (lambda e: int(e) if e == int(e) else e)(-p * __import__('math').log2(p) - (1-p) * __import__('math').log2(1-p)) if 0 < p < 1 else 0)(ones/n))(b.count('1'), len(b)))(bin(x)[2:]) if x > 0 else 0 for x in obj], 'mapBitSignature': lambda: [bin(x).count('1') ^ x.bit_length() if x > 0 else 0 for x in obj], 'mapBitChecksum': lambda: list(__import__('itertools').accumulate(obj, lambda a, b: a ^ b)), 'mapBitParity': lambda: [bin(x).count('1') % 2 for x in obj], 'mapBitSwapPairs': lambda: [((x & 0xAAAAAAAA) >> 1) | ((x & 0x55555555) << 1) for x in obj], 'mapBitSwapNibbles': lambda: [((x & 0x0F) << 4) | ((x & 0xF0) >> 4) for x in obj], 'mapBitReverse32': lambda: [int(bin(x)[2:].zfill(32)[::-1], 2) for x in obj], 'mapBitIsolateLowest': lambda: [x & (-x) if x != 0 else 0 for x in obj], 'mapBitClearLowest': lambda: [x & (x - 1) if x != 0 else 0 for x in obj], 'mapBitSetLowest': lambda: [x | (x + 1) for x in obj], 'mapBitIsPowerOf2': lambda: [x > 0 and (x & (x - 1)) == 0 for x in obj], 'mapBitNextPowerOf2': lambda: [1 << (x - 1).bit_length() if x > 0 else 1 for x in obj], 'mapBitPrevPowerOf2': lambda: [1 << (x.bit_length() - 1) if x > 0 else 0 for x in obj], 'mapBitCeilPowerOf2': lambda: [1 << (x - 1).bit_length() if x > 1 else x for x in obj], 'mapBitFloorPowerOf2': lambda: [1 << (x.bit_length() - 1) if x > 0 else 0 for x in obj], 'mapBitCountLeadingOnes': lambda: [(lambda b: len(b) - len(b.lstrip('1')))(bin(x)[2:]) if x > 0 else 0 for x in obj], 'mapBitCountTrailingOnes': lambda: [(lambda b: len(b) - len(b.rstrip('1')))(bin(x)[2:]) if x > 0 else 0 for x in obj], 'mapBitHighestBit': lambda: [1 << (x.bit_length() - 1) if x > 0 else 0 for x in obj], 'mapBitLowestBit': lambda: [(x & (-x)).bit_length() - 1 if x > 0 else -1 for x in obj], 'mapBitPopParity': lambda: [bin(x).count('1') % 2 for x in obj], 'mapBitMaskLow': lambda: [x & ((1 << (x.bit_length() // 2)) - 1) if x > 0 else 0 for x in obj], 'mapBitMaskHigh': lambda: [x & (((1 << (x.bit_length() // 2)) - 1) << (x.bit_length() - x.bit_length() // 2)) if x > 0 else 0 for x in obj], 'mapBitMaskOdd': lambda: [x & 0xAAAAAAAA for x in obj], 'mapBitMaskEven': lambda: [x & 0x55555555 for x in obj], 'mapBitMaskNibble': lambda: [x & 0xF for x in obj], 'mapBitMaskByte': lambda: [x & 0xFF for x in obj], 'mapBitMaskWord': lambda: [x & 0xFFFF for x in obj], 'mapBitRotateLeft8': lambda: [((x << 1) | (x >> 7)) & 0xFF for x in obj], 'mapBitRotateRight8': lambda: [((x >> 1) | ((x & 1) << 7)) & 0xFF for x in obj], 'mapBitRotateLeft16': lambda: [((x << 1) | (x >> 15)) & 0xFFFF for x in obj], 'mapBitRotateRight16': lambda: [((x >> 1) | ((x & 1) << 15)) & 0xFFFF for x in obj], 'mapBitSaturateAdd8': lambda: [min(obj[i] + obj[i+1], 255) for i in range(len(obj)-1)], 'mapBitSaturateSub8': lambda: [max(obj[i] - obj[i+1], 0) for i in range(len(obj)-1)], 'mapBitSaturateAdd16': lambda: [min(obj[i] + obj[i+1], 65535) for i in range(len(obj)-1)], 'mapBitSaturateSub16': lambda: [max(obj[i] - obj[i+1], 0) for i in range(len(obj)-1)], 'mapBitSaturateAdd32': lambda: [min(obj[i] + obj[i+1], 4294967295) for i in range(len(obj)-1)], 'mapBitSaturateSub32': lambda: [max(obj[i] - obj[i+1], 0) for i in range(len(obj)-1)], 'mapBitClamp8': lambda: [max(0, min(x, 255)) for x in obj], 'mapBitClamp16': lambda: [max(0, min(x, 65535)) for x in obj], 'mapBitClamp32': lambda: [max(0, min(x, 4294967295)) for x in obj], 'mapBitWrap8': lambda: [x % 256 for x in obj], 'mapBitWrap16': lambda: [x % 65536 for x in obj], 'mapBitWrap32': lambda: [x % 4294967296 for x in obj], 'mapBitScale8': lambda: (lambda mn, mx: [int((x - mn) / (mx - mn) * 255) if mx != mn else 0 for x in obj])(min(obj), max(obj)), 'mapBitScale16': lambda: (lambda mn, mx: [int((x - mn) / (mx - mn) * 65535) if mx != mn else 0 for x in obj])(min(obj), max(obj)), 'mapBitScale32': lambda: (lambda mn, mx: [int((x - mn) / (mx - mn) * 4294967295) if mx != mn else 0 for x in obj])(min(obj), max(obj)), 'mapBitQuantize4': lambda: [x // 4 * 4 for x in obj], 'mapBitQuantize8': lambda: [x // 8 * 8 for x in obj], 'mapBitQuantize16': lambda: [x // 16 * 16 for x in obj], 'mapBitQuantize32': lambda: [x // 32 * 32 for x in obj], 'mapBitQuantize64': lambda: [x // 64 * 64 for x in obj], 'mapBitQuantize128': lambda: [x // 128 * 128 for x in obj], 'mapBitQuantize256': lambda: [x // 256 * 256 for x in obj], 'mapBitQuantize512': lambda: [x // 512 * 512 for x in obj], 'mapBitQuantize1024': lambda: [x // 1024 * 1024 for x in obj], 'mapBitRoundUp8': lambda: [(x + 7) // 8 * 8 if x else 0 for x in obj], 'mapBitRoundUp16': lambda: [(x + 15) // 16 * 16 if x else 0 for x in obj], 'mapBitRoundUp32': lambda: [(x + 31) // 32 * 32 if x else 0 for x in obj], 'mapBitRoundUp64': lambda: [(x + 63) // 64 * 64 if x else 0 for x in obj], 'mapBitRoundUp128': lambda: [(x + 127) // 128 * 128 if x else 0 for x in obj], 'mapBitRoundUp256': lambda: [(x + 255) // 256 * 256 if x else 0 for x in obj], 'mapBitRoundUp512': lambda: [(x + 511) // 512 * 512 if x else 0 for x in obj], 'mapBitRoundUp1024': lambda: [(x + 1023) // 1024 * 1024 if x else 0 for x in obj], 'mapBitRoundUp2048': lambda: [(x + 2047) // 2048 * 2048 if x else 0 for x in obj], 'mapBitRoundUp4096': lambda: [(x + 4095) // 4096 * 4096 if x else 0 for x in obj], 'mapBitRoundUp8192': lambda: [(x + 8191) // 8192 * 8192 if x else 0 for x in obj], 'mapBitRoundDown8': lambda: [x // 8 * 8 for x in obj], 'mapBitRoundDown16': lambda: [x // 16 * 16 for x in obj], 'mapBitRoundDown32': lambda: [x // 32 * 32 for x in obj], 'mapBitRoundDown64': lambda: [x // 64 * 64 for x in obj], 'mapBitRoundDown128': lambda: [x // 128 * 128 for x in obj], 'mapBitRoundDown256': lambda: [x // 256 * 256 for x in obj], 'mapBitRoundDown512': lambda: [x // 512 * 512 for x in obj], 'mapBitRoundDown1024': lambda: [x // 1024 * 1024 for x in obj], 'mapBitRoundDown2048': lambda: [x // 2048 * 2048 for x in obj], 'mapBitAlign8': lambda: [(x + 7) // 8 * 8 if x else 0 for x in obj], 'mapBitAlign16': lambda: [(x + 15) // 16 * 16 if x else 0 for x in obj], 'mapBitAlign32': lambda: [(x + 31) // 32 * 32 if x else 0 for x in obj], 'mapBitAlign64': lambda: [(x + 63) // 64 * 64 if x else 0 for x in obj], 'mapBitAlign128': lambda: [(x + 127) // 128 * 128 if x else 0 for x in obj], 'mapBitAlign256': lambda: [(x + 255) // 256 * 256 if x else 0 for x in obj], 'mapBitAlign512': lambda: [(x + 511) // 512 * 512 if x else 0 for x in obj], 'mapBitAlign1024': lambda: [(x + 1023) // 1024 * 1024 if x else 0 for x in obj], 'mapBitAlign2048': lambda: [(x + 2047) // 2048 * 2048 if x else 0 for x in obj], 'mapBitAlign4096': lambda: [(x + 4095) // 4096 * 4096 if x else 0 for x in obj], 'mapBitAlign8192': lambda: [(x + 8191) // 8192 * 8192 if x else 0 for x in obj], 'mapBitAlign16384': lambda: [(x + 16383) // 16384 * 16384 if x else 0 for x in obj], 'mapBitAlign32768': lambda: [(x + 32767) // 32768 * 32768 if x else 0 for x in obj], 'mapBitAlign65536': lambda: [(x + 65535) // 65536 * 65536 if x else 0 for x in obj], 'mapBitAlign131072': lambda: [(x + 131071) // 131072 * 131072 if x else 0 for x in obj], 'mapBitAlign262144': lambda: [(x + 262143) // 262144 * 262144 if x else 0 for x in obj], 'mapBitAlign524288': lambda: [(x + 524287) // 524288 * 524288 if x else 0 for x in obj], 'mapBitAlign1048576': lambda: [(x + 1048575) // 1048576 * 1048576 if x else 0 for x in obj],
        }
        if member in _noarg:
            fn = _noarg[member]
            return ('builtin', lambda args, ctx: fn())
        # Simple one-arg methods
        _onearg = {
            'push': lambda a: obj.append(a[0]) or obj,
            'contains': lambda a: a[0] in obj,
            'join': lambda a: a[0].join(silk_repr(item) for item in obj),
            'take': lambda a: obj[:int(a[0])], 'head': lambda a: obj[:int(a[0])],
            'skip': lambda a: obj[int(a[0]):], 'dropFirst': lambda a: obj[int(a[0]):],
            'tail': lambda a: obj[-int(a[0]):] if int(a[0]) <= len(obj) else list(obj),
            'without': lambda a: [x for x in obj if x not in a[0]],
            'difference': lambda a: [x for x in obj if x not in a[0]],
            'intersection': lambda a: [x for x in obj if x in a[0]],
            'zip': lambda a: [[x, y] for x, y in zip(obj, a[0])],
            'sample': lambda a: random.sample(list(obj), min(int(a[0]), len(obj))), 'takeRandom': lambda a: random.sample(list(obj), min(int(a[0]), len(obj))),
            'dotProduct': lambda a: sum(x * y for x, y in zip(obj, a[0])), 'mapModulo': lambda a: [x % int(a[0]) for x in obj], 'mapDivide': lambda a: [(lambda r: int(r) if r == int(r) else r)(x / int(a[0])) for x in obj], 'mapMultiply': lambda a: [x * int(a[0]) for x in obj], 'mapAdd': lambda a: [x + int(a[0]) for x in obj], 'mapSubtract': lambda a: [x - int(a[0]) for x in obj], 'mapFloorDivide': lambda a: [x // int(a[0]) for x in obj], 'mapPower': lambda a: [x ** int(a[0]) for x in obj], 'mapClamp': lambda a: [max(int(a[0]), min(int(a[1]), x)) for x in obj], 'mapScale': lambda a: (lambda mn, mx, s: [(lambda r: int(r) if r == int(r) else r)((x - mn) / (mx - mn) * s) if mx != mn else 0 for x in obj])(min(obj), max(obj), int(a[0])), 'mapBitAnd': lambda a: [x & int(a[0]) for x in obj], 'mapBitOr': lambda a: [x | int(a[0]) for x in obj], 'mapBitXor': lambda a: [x ^ int(a[0]) for x in obj], 'mapBitShiftLeft': lambda a: [x << int(a[0]) for x in obj], 'mapBitShiftRight': lambda a: [x >> int(a[0]) for x in obj], 'mapBitRotateLeft': lambda a: (lambda n: [((x << n) | (x >> (8 - n))) & 255 for x in obj])(int(a[0]) % 8), 'mapBitRotateRight': lambda a: (lambda n: [((x >> n) | (x << (8 - n))) & 255 for x in obj])(int(a[0]) % 8), 'mapBitMask': lambda a: (lambda m: [x & m for x in obj])((1 << int(a[0])) - 1), 'mapBitExtract': lambda a: [(x >> int(a[0])) & 1 for x in obj], 'mapBitSet': lambda a: [x | (1 << int(a[0])) for x in obj], 'mapBitClear': lambda a: [x & ~(1 << int(a[0])) for x in obj], 'mapBitToggle': lambda a: [x ^ (1 << int(a[0])) for x in obj], 'mapBitTest': lambda a: [bool((x >> int(a[0])) & 1) for x in obj],
            'zipWith': lambda a: [self._call_function(a[1], [x, y]) for x, y in zip(obj, a[0])],
            'windows': lambda a: [obj[i:i+int(a[0])] for i in range(len(obj) - int(a[0]) + 1)], 'aperture': lambda a: [obj[i:i+int(a[0])] for i in range(len(obj) - int(a[0]) + 1)],
            'splitAt': lambda a: [obj[:int(a[0])], obj[int(a[0]):]],  'mapSplitAt': lambda a: [obj[:int(a[0])], obj[int(a[0]):]],
            'cycle': lambda a: obj * int(a[0]),
            'takeRight': lambda a: obj[-int(a[0]):] if int(a[0]) > 0 else [],
            'dropRight': lambda a: obj[:-int(a[0])] if int(a[0]) > 0 else list(obj),
            'intersperse': lambda a: [x for i, v in enumerate(obj) for x in (([a[0], v] if i > 0 else [v]))],
            'takeEvery': lambda a: obj[::int(a[0])],
            'everyNth': lambda a: obj[int(a[0])-1::int(a[0])], 'lastIndexOf': lambda a: next((i for i in range(len(obj)-1, -1, -1) if obj[i] == a[0]), -1), 'countOf': lambda a: sum(1 for x in obj if x == a[0]), 'removeAll': lambda a: [x for x in obj if x != a[0]], 'fillCycle': lambda a: [obj[i % len(obj)] for i in range(int(a[0]))], 'padRight': lambda a: obj + [obj[-1]] * max(0, int(a[0]) - len(obj)), 'padLeft': lambda a: [obj[0]] * max(0, int(a[0]) - len(obj)) + obj, 'mapMovingAvg': lambda a: [(lambda s: int(s) if s == int(s) else s)(sum(obj[i:i+int(a[0])])/int(a[0])) for i in range(len(obj)-int(a[0])+1)], 'mapEWMA': lambda a: (lambda al: list(__import__('functools').reduce(lambda acc, x: acc + [(lambda v: int(v) if v == int(v) else v)(al * x + (1 - al) * acc[-1])], obj[1:], [obj[0]])))( float(a[0])),
        }
        if member in _onearg:
            fn = _onearg[member]
            return ('builtin', lambda args, ctx: fn(args))
        if member == 'slice': return ('builtin', lambda args, ctx: obj[int(args[0]):int(args[1])])
        if member == 'zip3': return ('builtin', lambda args, ctx: [[x, y, z] for x, y, z in zip(obj, args[0], args[1])])
        if member == 'indexOf': return ('builtin', lambda args, ctx: obj.index(args[0]) if args[0] in obj else -1)
        if member in ('map', 'collectMap', 'mapAsync'): return ('builtin', lambda args, ctx: [self._call_function(args[0], [item]) for item in obj])
        if member == 'mapNotNull': return ('builtin', lambda args, ctx: [r for item in obj if (r := self._call_function(args[0], [item])) is not None])
        if member == 'filter': return ('builtin', lambda args, ctx: [item for item in obj if self._call_function(args[0], [item])])
        if member == 'forEach': return ('builtin', lambda args, ctx: [self._call_function(args[0], [x]) for x in obj] and None)
        if member == 'reduce': return ('builtin', lambda args, ctx: __import__('functools').reduce(lambda acc, x: self._call_function(args[0], [acc, x]), obj, args[1]))
        if member == 'find': return ('builtin', lambda args, ctx: next((x for x in obj if self._call_function(args[0], [x])), None))
        if member == 'findIndex': return ('builtin', lambda args, ctx: next((i for i, x in enumerate(obj) if self._call_function(args[0], [x])), -1))
        if member in ('every', 'all'): return ('builtin', lambda args, ctx: all(self._call_function(args[0], [item]) for item in obj))
        if member in ('some', 'any'): return ('builtin', lambda args, ctx: any(self._call_function(args[0], [item]) for item in obj))
        if member == 'flat': return ('builtin', lambda args, ctx: [x for i in obj for x in (i if isinstance(i, list) else [i])])
        if member == 'flattenDeep': return ('builtin', lambda args, ctx: (f := lambda a: [x for i in a for x in (f(i) if isinstance(i, list) else [i])])(obj))
        if member in ('flatMap', 'mapFlat'): return ('builtin', lambda args, ctx: [y for x in obj for y in (lambda m: m if isinstance(m, list) else [m])(self._call_function(args[0], [x]))])
        if member == 'unique': return ('builtin', lambda args, ctx: list(dict.fromkeys(obj)))
        if member == 'count': return ('builtin', lambda args, ctx: sum(1 for item in obj if self._call_function(args[0], [item])))
        if member == 'sortBy': return ('builtin', lambda args, ctx: sorted(obj, key=lambda item: self._call_function(args[0], [item])))
        if member == 'groupBy': return ('builtin', lambda args, ctx: (lambda g: [g.setdefault(self._call_function(args[0], [x]), []).append(x) for x in obj] and g or g)({}))
        if member == 'countBy': return ('builtin', lambda args, ctx: (lambda c: [c.update({(k := self._call_function(args[0], [x])): c.get(k, 0) + 1}) for x in obj] and c or c)({}))
        if member in ('chunked', 'chunk'): return ('builtin', lambda args, ctx: [obj[i:i+int(args[0])] for i in range(0, len(obj), int(args[0]))])
        if member in ('window', 'windowed'): return ('builtin', lambda args, ctx: [obj[i:i+int(args[0])] for i in range(len(obj) - int(args[0]) + 1)])
        if member == 'rotate': return ('builtin', lambda args, ctx: (lambda n: obj[-n:] + obj[:-n] if n else list(obj))(int(args[0]) % len(obj)) if obj else [])
        if member == 'partition': return ('builtin', lambda args, ctx: (lambda y, n: [(y if self._call_function(args[0], [x]) else n).append(x) for x in obj] and [y, n] or [y, n])([], []))
        if member == 'findLast': return ('builtin', lambda args, ctx: next((x for x in reversed(obj) if self._call_function(args[0], [x])), None))
        if member == 'findLastIndex': return ('builtin', lambda args, ctx: next((i for i in range(len(obj)-1, -1, -1) if self._call_function(args[0], [obj[i]])), -1))
        if member in ('tally', 'frequencies', 'histogram'): return ('builtin', lambda args, ctx: (lambda c: [c.update({x: c.get(x, 0) + 1}) for x in obj] and c or c)({}))
        if member == 'interleave': return ('builtin', lambda args, ctx: [x for i in range(max(len(obj), len(args[0]))) for x in ([obj[i]] if i < len(obj) else []) + ([args[0][i]] if i < len(args[0]) else [])])
        if member == 'interleaveAll': return ('builtin', lambda args, ctx: (lambda arrs: [arrs[j][i] for i in range(max(len(a) for a in arrs)) for j in range(len(arrs)) if i < len(arrs[j])])([obj] + list(args)))
        if member == 'flatten': return ('builtin', lambda args, ctx: (f := lambda a, d: [x for i in a for x in (f(i, d-1) if isinstance(i, list) and d > 0 else [i])])(obj, int(args[0]) if args else 1))
        if member == 'takeWhile': return ('builtin', lambda args, ctx: list(__import__('itertools').takewhile(lambda x: self._call_function(args[0], [x]), obj)))
        if member in ('skipWhile', 'dropWhile'): return ('builtin', lambda args, ctx: list(__import__('itertools').dropwhile(lambda x: self._call_function(args[0], [x]), obj)))
        if member in ('scan', 'scanRight'): return ('builtin', lambda args, ctx: (lambda r, items: [r.append(self._call_function(args[0], [r[-1], x])) or None for x in items] and (r[1:][::-1] if member == 'scanRight' else r[1:]))([args[1]], reversed(obj) if member == 'scanRight' else obj))
        if member == 'product': return ('builtin', lambda args, ctx: __import__('functools').reduce(lambda a, b: a * b, obj, 1))
        if member in ('mapIndexed', 'mapWithIndex'): return ('builtin', lambda args, ctx: [self._call_function(args[0], [i, item]) for i, item in enumerate(obj)])
        if member == 'average': return ('builtin', lambda args, ctx: (lambda r: int(r) if r == int(r) else r)(sum(obj) / len(obj)))
        if member == 'none': return ('builtin', lambda args, ctx: not any(self._call_function(args[0], [item]) for item in obj))
        if member == 'reject': return ('builtin', lambda args, ctx: [item for item in obj if not self._call_function(args[0], [item])])
        if member == 'union': return ('builtin', lambda args, ctx: list(dict.fromkeys(obj + args[0])))
        if member == 'shuffle': return ('builtin', lambda args, ctx: random.sample(obj, len(obj)))
        if member == 'forEachIndexed': return ('builtin', lambda args, ctx: [self._call_function(args[0], [i, x]) for i, x in enumerate(obj)] and None)
        if member == 'symmetricDifference': return ('builtin', lambda args, ctx: [x for x in obj if x not in args[0]] + [x for x in args[0] if x not in obj])
        if member == 'at': return ('builtin', lambda args, ctx: obj[int(args[0])] if -len(obj) <= int(args[0]) < len(obj) else None)
        if member == 'associate': return ('builtin', lambda args, ctx: {(p := self._call_function(args[0], [x]))[0]: p[1] for x in obj})
        if member == 'interpose': return ('builtin', lambda args, ctx: [x for i, v in enumerate(obj) for x in ([args[0], v] if i > 0 else [v])])
        if member == 'juxtapose': return ('builtin', lambda args, ctx: [[self._call_function(fn, [x]) for fn in args[0]] for x in obj])
        if member == 'crossProduct': return ('builtin', lambda args, ctx: [[a, b] for a in obj for b in args[0]])
        if member == 'interleaveN': return ('builtin', lambda args, ctx: (lambda arrs: [arrs[j][i] for i in range(max(len(a) for a in arrs)) for j in range(len(arrs)) if i < len(arrs[j])])([obj] + args[0]))
        if member == 'transpose': return ('builtin', lambda args, ctx: [list(row) for row in zip(*obj)])
        if member == 'combinations': return ('builtin', lambda args, ctx: [list(c) for c in __import__('itertools').combinations(obj, int(args[0]))])
        if member == 'permutations': return ('builtin', lambda args, ctx: [list(p) for p in __import__('itertools').permutations(obj)])
        if member == 'mapTruncateTo': return ('builtin', lambda args, ctx: obj[:int(args[0])])
        if member == 'mapPadLeft': return ('builtin', lambda args, ctx: [args[1]] * max(0, int(args[0]) - len(obj)) + obj)
        if member == 'mapPadRight': return ('builtin', lambda args, ctx: obj + [args[1]] * max(0, int(args[0]) - len(obj)))
        if member == 'median': return ('builtin', lambda args, ctx: (lambda s, n: s[n//2] if n % 2 else (lambda m: m/2 if m % 2 else m//2)(s[n//2-1]+s[n//2]))(sorted(obj), len(obj)))
        if member == 'mode': return ('builtin', lambda args, ctx: (lambda c: [k for k, v in c.items() if v == max(c.values())])((lambda c: [c.update({x: c.get(x, 0) + 1}) for x in obj] and c or c)({})))
        if member in ('stddev', 'variance'): return ('builtin', lambda args, ctx: (lambda r: int(r) if r == int(r) else r)((lambda v: v ** 0.5 if member == 'stddev' else v)(sum((x - sum(obj)/len(obj)) ** 2 for x in obj) / len(obj))))
        if member in ('chunkBy', 'partitionBy', 'segmentBy'): return ('builtin', lambda args, ctx: [list(g) for _, g in __import__('itertools').groupby(obj, key=lambda x: self._call_function(args[0], [x]))] if obj else [])
        if member == 'sliding': return ('builtin', lambda args, ctx: [obj[i:i+int(args[0])] for i in range(0, len(obj) - int(args[0]) + 1, int(args[1]))])
        if member in ('span', 'splitWhen'): return ('builtin', lambda args, ctx: (lambda i: [obj[:i], obj[i:]] if (member == 'span' or i < len(obj)) else [list(obj)])(next((i for i, x in enumerate(obj) if (not self._call_function(args[0], [x]) if member == 'span' else self._call_function(args[0], [x]))), len(obj))))
        if member == 'mapWhile': return ('builtin', lambda args, ctx: list(__import__('itertools').takewhile(lambda v: v is not False, (self._call_function(args[0], [x]) for x in obj))))
        if member == 'groupConsecutive': return ('builtin', lambda args, ctx: [list(g) for _, g in __import__('itertools').groupby(obj)] if obj else [])
        if member in ('mapFirst', 'mapLast'): return ('builtin', lambda args, ctx: [] if not obj else (lambda r: r.__setitem__(0 if member == 'mapFirst' else -1, self._call_function(args[0], [r[0 if member == 'mapFirst' else -1]])) or r)(list(obj)))
        if member in ('minBy', 'maxBy'): return ('builtin', lambda args, ctx: (min if member == 'minBy' else max)(obj, key=lambda x: self._call_function(args[0], [x])))
        if member in ('forEachRight', 'mapRight'): return ('builtin', lambda args, ctx: (lambda r: None if member == 'forEachRight' else r)([self._call_function(args[0], [x]) for x in reversed(obj)]))
        if member == 'tapEach': return ('builtin', lambda args, ctx: [self._call_function(args[0], [x]) for x in obj] and obj)
        if member in ('filterRight', 'findRight', 'findIndexRight', 'countRight'):
            return ('builtin', lambda args, ctx: [x for x in reversed(obj) if self._call_function(args[0], [x])] if member == 'filterRight' else next((x for x in reversed(obj) if self._call_function(args[0], [x])), None) if member == 'findRight' else sum(1 for x in obj if self._call_function(args[0], [x])) if member == 'countRight' else next((i for i in range(len(obj)-1, -1, -1) if self._call_function(args[0], [obj[i]])), -1))
        if member == 'mapWhileIndexed': return ('builtin', lambda args, ctx: list(__import__('itertools').takewhile(lambda v: v is not False, (self._call_function(args[0], [i, x]) for i, x in enumerate(obj)))))
        if member in ('noneIndexed', 'everyIndexed', 'someIndexed'): return ('builtin', lambda args, ctx, fn={'noneIndexed': lambda g: not any(g), 'everyIndexed': all, 'someIndexed': any}[member]: fn(self._call_function(args[0], [i, x]) for i, x in enumerate(obj)))
        if member == 'flatMapIndexed': return ('builtin', lambda args, ctx: [y for i, x in enumerate(obj) for y in (lambda m: m if isinstance(m, list) else [m])(self._call_function(args[0], [i, x]))])
        if member == 'reduceIndexed': return ('builtin', lambda args, ctx: __import__('functools').reduce(lambda acc, ix: self._call_function(args[0], [acc, ix[0], ix[1]]), enumerate(obj), args[1]))
        if member in ('filterIndexed', 'filterMapIndexed'): return ('builtin', lambda args, ctx: [x for i, x in enumerate(obj) if self._call_function(args[0], [i, x])])
        if member == 'groupByCount': return ('builtin', lambda args, ctx: (lambda n, s: [obj[i*s:(i+1)*s] for i in range(n)])(int(args[0]), len(obj) // int(args[0])))
        if member == 'uniqueBy': return ('builtin', lambda args, ctx: (lambda s: [x for x in obj if (k := self._call_function(args[0], [x])) not in s and not s.add(k)])(set()))
        if member in ('pairMap', 'mapPairs', 'mapWithNext', 'mapBetween'): return ('builtin', lambda args, ctx: [self._call_function(args[0], [obj[i], obj[i+1]]) for i in range(len(obj) - 1)])
        if member == 'runLengthEncode': return ('builtin', lambda args, ctx: [[k, sum(1 for _ in g)] for k, g in __import__('itertools').groupby(obj)] if obj else [])
        if member in ('mapAccum', 'mapAccumRight'): return ('builtin', lambda args, ctx: (lambda: (r := [[], args[1]]) and [r.__setitem__(1, (p := self._call_function(args[0], [r[1], x]))[1]) or r[0].append(p[0]) for x in (reversed(obj) if member == 'mapAccumRight' else obj)] and ([r[0][::-1], r[1]] if member == 'mapAccumRight' else r))())
        if member == 'toDict': return ('builtin', lambda args, ctx: dict(zip(obj, args[0])))
        if member == 'weightedAverage': return ('builtin', lambda args, ctx: (lambda r: int(r) if r == int(r) else r)(sum(v*w for v, w in zip(obj, args[0])) / sum(args[0])))
        if member in ('foldRight', 'reduceRight'): return ('builtin', lambda args, ctx: __import__('functools').reduce(lambda acc, x: self._call_function(args[0], [acc, x]), reversed(obj), args[1]))
        if member == 'reduceWhile': return ('builtin', lambda args, ctx: (lambda: (s := [args[0]]) and [((s.__setitem__(0, r) or True) if (r := self._call_function(args[1], [s[0], x])) is not False else None) for x in obj] and s[0])())
        if member in ('unfold', 'iterate'): return ('builtin', lambda args, ctx: (lambda s, fn, n: (r := [s]) and [r.append(fn(r[-1])) for _ in range(n-1)] and r)(args[0], lambda x: self._call_function(args[1], [x]), int(args[2])))
        if member == 'mapEvery': return ('builtin', lambda args, ctx: [self._call_function(args[1], [x]) if (i+1) % int(args[0]) == 0 else x for i, x in enumerate(obj)])
        if member in ('takeWhileRight', 'dropWhileRight'): return ('builtin', lambda args, ctx: (lambda r: list(reversed(r)) if member == 'takeWhileRight' else obj[:len(obj)-len(r)])(list(__import__('itertools').takewhile(lambda x: self._call_function(args[0], [x]), reversed(obj)))))
        if member in ('mapPrev', 'mapWithBoth'): return ('builtin', lambda args, ctx: [self._call_function(args[0], [obj[i-1] if i > 0 else obj[i], obj[i]] + ([obj[i+1] if i < len(obj)-1 else obj[i]] if member == 'mapWithBoth' else [])) for i in range(len(obj))])
        if member == 'mapWithContext': return ('builtin', lambda args, ctx: (lambda: (s := [args[0]]) and [s.append(self._call_function(args[1], [s[-1], x])) for x in obj] and s[1:])())
        if member == 'foldMap': return ('builtin', lambda args, ctx: sum(self._call_function(args[0], [x]) for x in obj))
        if member == 'mapZip': return ('builtin', lambda args, ctx: [self._call_function(args[1], [a, b]) for a, b in zip(obj, args[0])])
        if member == 'mapWithLast': return ('builtin', lambda args, ctx: (lambda: (r := [obj[0]]) and [r.append(self._call_function(args[0], [obj[i], r[-1]])) for i in range(1, len(obj))] and r)())
        if member == 'mapUntil': return ('builtin', lambda args, ctx: (lambda: (s := [False]) and [(x if s[0] else (s.__setitem__(0, True) or x) if self._call_function(args[0], [x]) else self._call_function(args[1], [x])) for x in obj])())
        if member == 'mapAdjacent': return ('builtin', lambda args, ctx: [self._call_function(args[1], obj[i:i+int(args[0])]) for i in range(len(obj) - int(args[0]) + 1)])
        if member == 'mapChunked': return ('builtin', lambda args, ctx: [self._call_function(args[1], obj[i:i+int(args[0])]) for i in range(0, len(obj), int(args[0]))])
        if member == 'mapWhere': return ('builtin', lambda args, ctx: [self._call_function(args[1], [x]) if self._call_function(args[0], [x]) else x for x in obj])
        if member == 'mapReverse': return ('builtin', lambda args, ctx: [self._call_function(args[0], [x]) for x in reversed(obj)])
        if member in ('mapFlatMap', 'mapConcat'): return ('builtin', lambda args, ctx: [y for x in obj for y in (lambda r: r if isinstance(r, list) else [r])(self._call_function(args[0], [x]))])
        if member == 'mapPairwise': return ('builtin', lambda args, ctx: [self._call_function(args[0], [obj[i], obj[i+1]]) for i in range(0, len(obj) - 1, 2)])
        if member in ('mapExcept', 'mapOnly'): return ('builtin', lambda args, ctx: [(self._call_function(args[1], [obj[i]]) if (i in args[0]) == (member == 'mapOnly') else obj[i]) for i in range(len(obj))])
        if member in ('mapSkip', 'mapTake'): return ('builtin', lambda args, ctx: [(obj[i] if i < int(args[0]) else self._call_function(args[1], [obj[i]])) if member == 'mapSkip' else (self._call_function(args[1], [obj[i]]) if i < int(args[0]) else obj[i]) for i in range(len(obj))])
        if member == 'mapIntersperse': return ('builtin', lambda args, ctx: [v for i, x in enumerate(obj) for v in (([args[0], x] if i else [x]))])
        if member == 'mapBatch': return ('builtin', lambda args, ctx: [self._call_function(args[1], [obj[i:i+int(args[0])]]) for i in range(0, len(obj), int(args[0]))])
        if member in ('mapTakeWhile', 'mapDropWhile'): return ('builtin', lambda args, ctx: list(__import__('itertools').takewhile(lambda x: self._call_function(args[0], [x]), obj)) if member == 'mapTakeWhile' else list(__import__('itertools').dropwhile(lambda x: self._call_function(args[0], [x]), obj)))
        if member == 'mapScan': return ('builtin', lambda args, ctx: list(__import__('itertools').accumulate(obj, lambda a, x: self._call_function(args[1], [a, x]), initial=args[0]))[1:])
        if member == 'mapPartition': return ('builtin', lambda args, ctx: [[x for x in obj if self._call_function(args[0], [x])], [x for x in obj if not self._call_function(args[0], [x])]])
        if member == 'mapGroupBy': return ('builtin', lambda args, ctx: (lambda d: [d.setdefault(self._call_function(args[0], [x]), []).append(x) for x in obj] and d)({}))
        if member == 'mapZipWith': return ('builtin', lambda args, ctx: [[a, b] for a, b in zip(obj, args[0])])
        if member == 'mapWindow': return ('builtin', lambda args, ctx: [obj[i:i+int(args[0])] for i in range(len(obj)-int(args[0])+1)])
        if member == 'mapChunkEvery': return ('builtin', lambda args, ctx: [obj[i:i+int(args[0])] for i in range(0, len(obj), int(args[0]))])
        if member == 'mapRotate': return ('builtin', lambda args, ctx: (lambda n: obj[n:] + obj[:n])(int(args[0]) % len(obj) if obj else 0))
        if member == 'mapConsecutive': return ('builtin', lambda args, ctx: [self._call_function(args[1], [obj[i:i+int(args[0])]]) for i in range(len(obj)-int(args[0])+1)])
        if member == 'mapStutter': return ('builtin', lambda args, ctx: [x for item in obj for x in [item] * int(args[0])])
        if member == 'mapDedupBy': return ('builtin', lambda args, ctx: (lambda s: [x for x in obj if (k := self._call_function(args[0], [x])) not in s and not s.add(k)])(set()))
        if member == 'mapSplitWhen': return ('builtin', lambda args, ctx: (lambda i: [obj[:i], obj[i:]])(next((i for i, x in enumerate(obj) if self._call_function(args[0], [x])), len(obj))))
        if member == 'mapRepeat': return ('builtin', lambda args, ctx: obj * int(args[0]))
        if member == 'mapCycle': return ('builtin', lambda args, ctx: [obj[i % len(obj)] for i in range(int(args[0]))])
        if member in ('mapPartitionAt', 'mapInsertAt'): return ('builtin', lambda args, ctx, m=member: [obj[:int(args[0])], obj[int(args[0]):]] if m == 'mapPartitionAt' else obj[:int(args[0])] + [args[1]] + obj[int(args[0]):])
        if member in ('mapRemoveAt', 'mapReplaceAt'): return ('builtin', lambda args, ctx, m=member: obj[:int(args[0])] + obj[int(args[0])+1:] if m == 'mapRemoveAt' else obj[:int(args[0])] + [args[1]] + obj[int(args[0])+1:])
        if member in ('mapChunksOf', 'mapSwapAt'): return ('builtin', lambda args, ctx, m=member: (lambda n: [obj[i:i+n] for i in range(0, len(obj), n)])(int(args[0])) if m == 'mapChunksOf' else (lambda r, i, j: r.__setitem__(i, obj[j]) or r.__setitem__(j, obj[i]) or r)(list(obj), int(args[0]), int(args[1])))
        if member in ('mapCartesian', 'mapSelectIndices', 'mapRejectIndices'): return ('builtin', lambda args, ctx, m=member: [[a, b] for a in obj for b in args[0]] if m == 'mapCartesian' else [obj[i] for i in args[0] if 0 <= i < len(obj)] if m == 'mapSelectIndices' else [obj[i] for i in range(len(obj)) if i not in args[0]])
        if member in ('mapWindows', 'mapSliding'): return ('builtin', lambda args, ctx: (lambda n: [obj[i:i+n] for i in range(len(obj)-n+1)])(int(args[0])))
        if member in ('mapRotateLeft', 'mapRotateRight'): return ('builtin', lambda args, ctx, m=member: (lambda n: obj[n:] + obj[:n])(int(args[0]) % len(obj) if obj else 0) if m == 'mapRotateLeft' else (lambda n: obj[-n:] + obj[:-n] if n else list(obj))(int(args[0]) % len(obj) if obj else 0))
        if member in ('mapFillTo', 'mapInterleave'): return ('builtin', lambda args, ctx, m=member: obj + [args[1]] * max(0, int(args[0]) - len(obj)) if m == 'mapFillTo' else (lambda a, b: [v for p in __import__('itertools').zip_longest(a, b) for v in p if v is not None])(obj, args[0]))
        if member in ('mapNths', 'mapDropEvery', 'mapTakeEvery'): return ('builtin', lambda args, ctx, m=member: obj[::int(args[0])] if m == 'mapNths' else [x for i, x in enumerate(obj) if (i + 1) % int(args[0]) != 0] if m == 'mapDropEvery' else [x for i, x in enumerate(obj) if (i + 1) % int(args[0]) == 0])
        raise RuntimeError_(f"'list' has no member '{member}'")

    def _eval_string_member(self, obj: str, member: str) -> Any:
        """Evaluate member access on a string."""
        if member == 'length':
            return len(obj)
        # No-arg methods (return lambdas that ignore args)
        _noarg = {
            'upper': lambda: obj.upper(), 'toUpper': lambda: obj.upper(),
            'lower': lambda: obj.lower(), 'toLower': lambda: obj.lower(),
            'strip': lambda: obj.strip(), 'trim': lambda: obj.strip(),
            'trim_start': lambda: obj.lstrip(), 'trim_end': lambda: obj.rstrip(),
            'chars': lambda: list(obj), 'reverse': lambda: obj[::-1],
            'isEmpty': lambda: len(obj) == 0, 'words': lambda: obj.split(),
            'lines': lambda: obj.split('\n'), 'title': lambda: obj.title(),
            'capitalize': lambda: obj.capitalize(), 'swapCase': lambda: obj.swapcase(),
            'isDigit': lambda: len(obj) > 0 and obj.isdigit(), 'isAlpha': lambda: len(obj) > 0 and obj.isalpha(),
            'isUpper': lambda: len(obj) > 0 and obj.isupper(), 'isLower': lambda: len(obj) > 0 and obj.islower(),
            'isBlank': lambda: len(obj.strip()) == 0, 'isAlphanumeric': lambda: len(obj) > 0 and obj.isalnum(),
            'rot13': lambda: ''.join(chr((ord(c) - (65 if c.isupper() else 97) + 13) % 26 + (65 if c.isupper() else 97)) if c.isalpha() else c for c in obj), 'isPalindrome': lambda: obj == obj[::-1],
            'wordCount': lambda: len(obj.split()) if obj.strip() else 0, 'initials': lambda: ''.join(w[0].upper() for w in obj.split() if w), 'codePoints': lambda: [ord(c) for c in obj], 'toCharCodes': lambda: [ord(c) for c in obj],
            'isHexColor': lambda: bool(__import__('re').match(r'^#([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$', obj)), 'normalize': lambda: ' '.join(obj.split()),
            'isIPv4': lambda: len(p := obj.split('.')) == 4 and all(s.isdigit() and 0 <= int(s) <= 255 for s in p), 'isPangram': lambda: set('abcdefghijklmnopqrstuvwxyz').issubset(obj.lower()),
            'collapseWhitespace': lambda: ' '.join(obj.split()), 'reverseWords': lambda: ' '.join(obj.split()[::-1]),
            'trimLines': lambda: '\n'.join(l.strip() for l in obj.split('\n')),
            'removeDuplicateChars': lambda: ''.join(obj[i] for i in range(len(obj)) if i == 0 or obj[i] != obj[i-1]),
            'toAcronym': lambda: ''.join(w[0].upper() for w in obj.split() if w), 'sizeInBytes': lambda: len(obj.encode('utf-8')),
            'isWhitespace': lambda: len(obj) > 0 and obj.isspace(), 'isHex': lambda: len(obj) > 0 and all(c in '0123456789abcdefABCDEF' for c in obj),
            'isAscii': lambda: all(ord(c) < 128 for c in obj), 'toHashCode': lambda: hash(obj),
            'isDate': lambda: bool(__import__('re').match(r'^\d{4}-(0[1-9]|1[0-2])-(0[1-9]|[12]\d|3[01])$', obj)),
            'toSentenceCase': lambda: obj[0].upper() + obj[1:].lower() if obj else '',
            'isPhoneNumber': lambda: bool(__import__('re').match(r'^[\+]?[\d\s\-\(\)]{7,}$', obj)), 'countVowels': lambda: sum(1 for c in obj.lower() if c in 'aeiou'),
            'countConsonants': lambda: sum(1 for c in obj.lower() if c.isalpha() and c not in 'aeiou'), 'mirror': lambda: obj + obj[::-1],
            'toAlternatingCase': lambda: ''.join(c.upper() if i % 2 else c.lower() for i, c in enumerate(obj)), 'isUpperCamelCase': lambda: bool(__import__('re').match(r'^[A-Z][a-zA-Z0-9]*$', obj)),
            'isCamelCase': lambda: bool(__import__('re').match(r'^[a-z][a-zA-Z0-9]*$', obj)) and '_' not in obj, 'isSnakeCase': lambda: bool(__import__('re').match(r'^[a-z][a-z0-9_]*$', obj)) and '__' not in obj,
            'isKebabCase': lambda: bool(__import__('re').match(r'^[a-z][a-z0-9\-]*$', obj)) and '--' not in obj, 'squeezeBlanks': lambda: __import__('re').sub(r'\n{3,}', '\n\n', obj),
            'removeVowels': lambda: ''.join(c for c in obj if c.lower() not in 'aeiou'), 'removeConsonants': lambda: ''.join(c for c in obj if not c.isalpha() or c.lower() in 'aeiou'),
            'toCamelWords': lambda: __import__('re').sub(r'([a-z])([A-Z])', r'\1_\2', obj).split('_'), 'toWordArray': lambda: obj.split(), 'charCount': lambda: len(set(obj)),
            'encodeURI': lambda: __import__('urllib.parse', fromlist=['quote']).quote(obj, safe=''), 'decodeURI': lambda: __import__('urllib.parse', fromlist=['unquote']).unquote(obj),
            'toSlug': lambda: __import__('re').sub(r'-+', '-', __import__('re').sub(r'[^a-z0-9]+', '-', obj.lower())).strip('-'),
            'toSnakeCase': lambda: __import__('re').sub(r'[\s\-]+', '_', __import__('re').sub(r'([a-z])([A-Z])', r'\1_\2', obj)).lower(),
            'toCamelCase': lambda: (lambda w: w[0].lower() + ''.join(x.title() for x in w[1:]) if w else '')(__import__('re').split(r'[\s_\-]+', obj)),
            'toKebabCase': lambda: __import__('re').sub(r'[\s_]+', '-', __import__('re').sub(r'([a-z])([A-Z])', r'\1-\2', obj)).lower(),
            'toBase64': lambda: __import__('base64').b64encode(obj.encode()).decode(),
            'fromBase64': lambda: __import__('base64').b64decode(obj.encode()).decode(),
            'toMd5': lambda: __import__('hashlib').md5(obj.encode()).hexdigest(),
            'toSha256': lambda: __import__('hashlib').sha256(obj.encode()).hexdigest(), 'toHex': lambda: obj.encode().hex(), 'fromHex': lambda: bytes.fromhex(obj).decode(),
            'toROT13': lambda: obj.translate(str.maketrans('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz', 'NOPQRSTUVWXYZABCDEFGHIJKLMnopqrstuvwxyzabcdefghijklm')),
            'toCRC32': lambda: format(__import__('zlib').crc32(obj.encode()) & 0xFFFFFFFF, '08x'),
            'toMorseCode': lambda: ' '.join({'A':'.-','B':'-...','C':'-.-.','D':'-..','E':'.','F':'..-.','G':'--.','H':'....','I':'..','J':'.---','K':'-.-','L':'.-..','M':'--','N':'-.','O':'---','P':'.--.','Q':'--.-','R':'.-.','S':'...','T':'-','U':'..-','V':'...-','W':'.--','X':'-..-','Y':'-.--','Z':'--..','0':'-----','1':'.----','2':'..---','3':'...--','4':'....-','5':'.....','6':'-....','7':'--...','8':'---..','9':'----.'}[c] for c in obj.upper() if c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'),
            'toBraille': lambda: ''.join(chr(0x2800 + [1,3,9,25,17,11,27,19,10,26][ord(c)-ord('a')]) if 'a' <= c <= 'j' else chr(0x2800 + [5,7,13,29,21,15,31,23,14,30][ord(c)-ord('k')]) if 'k' <= c <= 't' else chr(0x2800 + [37,39,58,45,61,53][ord(c)-ord('u')]) if 'u' <= c <= 'z' else c for c in obj.lower()),
            'toNato': lambda: ' '.join({'A':'Alfa','B':'Bravo','C':'Charlie','D':'Delta','E':'Echo','F':'Foxtrot','G':'Golf','H':'Hotel','I':'India','J':'Juliet','K':'Kilo','L':'Lima','M':'Mike','N':'November','O':'Oscar','P':'Papa','Q':'Quebec','R':'Romeo','S':'Sierra','T':'Tango','U':'Uniform','V':'Victor','W':'Whiskey','X':'X-ray','Y':'Yankee','Z':'Zulu'}.get(c, c) for c in obj.upper() if c.isalpha()),
            'toPhonetic': lambda: '-'.join(c for c in obj.lower() if c.isalpha()), 'toAtbash': lambda: ''.join(chr(219 - ord(c)) if 'a' <= c <= 'z' else chr(155 - ord(c)) if 'A' <= c <= 'Z' else c for c in obj),
            'toA1Z26': lambda: '-'.join(str(ord(c) - 96) for c in obj.lower() if c.isalpha()),
            'toTapCode': lambda: ' '.join((lambda p: f'{p//5+1},{p%5+1}')((lambda c: ord(c)-ord('a') if c < 'k' else ord(c)-ord('a')-1)(c)) for c in obj.lower().replace('k','c') if c.isalpha()),
            'toPolybius': lambda: ' '.join((lambda p: f'{p//5+1}{p%5+1}')((lambda c: ord(c)-ord('a') if c < 'k' else ord(c)-ord('a')-1)(c)) for c in obj.lower().replace('k','c') if c.isalpha()),
            'toBacon': lambda: ' '.join(bin(ord(c) - ord('a'))[2:].zfill(5).replace('0', 'A').replace('1', 'B') for c in obj.lower() if c.isalpha()),
            'toSemaphore': lambda: ' '.join(str(ord(c) - ord('a') + 1) for c in obj.lower() if c.isalpha()), 'toASCIIArt': lambda: ' '.join(str(ord(c)) for c in obj),
            'toBinary': lambda: ' '.join(format(ord(c), '08b') for c in obj), 'toOctal': lambda: ' '.join(format(ord(c), 'o') for c in obj), 'toDecimal': lambda: ','.join(str(ord(c)) for c in obj), 'toUnicodeEscape': lambda: ''.join(f'\\u{ord(c):04x}' for c in obj),
            'toHTMLEntities': lambda: obj.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;').replace('"', '&quot;').replace("'", '&#39;'), 'toURLEncode': lambda: __import__('urllib.parse', fromlist=['quote']).quote(obj), 'toURLDecode': lambda: __import__('urllib.parse', fromlist=['unquote']).unquote(obj),
            'toPigLatin': lambda: ' '.join((w + 'yay' if w[0].lower() in 'aeiou' else (lambda i: w[i:] + w[:i] + 'ay')(next((j for j in range(len(w)) if w[j].lower() in 'aeiou'), len(w)))) for w in obj.split()),
            'toBase32': lambda: __import__('base64').b32encode(obj.encode()).decode().rstrip('='),
            'toROT47': lambda: ''.join(chr(33 + (ord(c) - 33 + 47) % 94) if 33 <= ord(c) <= 126 else c for c in obj),
            'toCharFreq': lambda: ' '.join(f'{c}:{obj.count(c)}' for c in dict.fromkeys(obj)),
            'toZalgo': lambda: ''.join(c + ''.join(chr(r) for r in __import__('random').choices(range(0x0300, 0x036f), k=3)) for c in obj),
            'toSpongeCase': lambda: ''.join(c.upper() if i % 2 else c.lower() for i, c in enumerate(obj)),
            'toTitleSnakeCase': lambda: '_'.join(w.capitalize() for w in __import__('re').split(r'[\s_\-]+', obj)),
            'toScreamingKebab': lambda: '-'.join(w.upper() for w in __import__('re').split(r'[\s_\-]+', obj)),
            'toWordReverse': lambda: ' '.join(w[::-1] for w in obj.split()),
            'toDotNotation': lambda: '.'.join(__import__('re').split(r'[\s_\-]+', obj)),
            'toUpperFirst': lambda: ' '.join(w[0].upper() + w[1:] if w else '' for w in obj.split(' ')),
            'toLowerFirst': lambda: ' '.join(w[0].lower() + w[1:] if w else '' for w in obj.split(' ')),
            'toAbbreviation': lambda: ''.join(w[0].upper() for w in obj.split() if w),
            'toInitials': lambda: '.'.join(w[0].upper() for w in obj.split() if w) + '.',
            'toSlugCase': lambda: '-'.join(w.lower() for w in __import__('re').split(r'[\s_\-]+', obj)),
            'toHeaderCase': lambda: '-'.join(w.capitalize() for w in __import__('re').split(r'[\s_\-]+', obj)),
            'toSwapCase': lambda: obj.swapcase(),
            'toSqueeze': lambda: ''.join(c for i, c in enumerate(obj) if i == 0 or c != obj[i-1]),
            'toRunLength': lambda: ''.join(f'{k}{sum(1 for _ in g)}' for k, g in __import__('itertools').groupby(obj)), 'toCharArray': lambda: list(obj), 'toWordBoundary': lambda: [w for w in __import__('re').split(r'(?<=[a-z])(?=[A-Z])|[\s_\-]+', obj) if w], 'toReverse': lambda: obj[::-1], 'toDoubleQuoted': lambda: '"' + obj + '"', 'toSingleQuoted': lambda: "'" + obj + "'", 'toBackticked': lambda: '`' + obj + '`', 'toParenthesized': lambda: '(' + obj + ')', 'toBracketed': lambda: '[' + obj + ']', 'toCurlyBraced': lambda: '{' + obj + '}', 'toAngleBracketed': lambda: '<' + obj + '>', 'toPipeDelimited': lambda: '|'.join(obj.split()), 'toCommaDelimited': lambda: ','.join(obj.split()), 'toTabDelimited': lambda: '\t'.join(obj.split()), 'toColonDelimited': lambda: ':'.join(obj.split()), 'toSemicolonDelimited': lambda: ';'.join(obj.split()), 'toDashDelimited': lambda: '-'.join(obj.split()), 'toSpaceDelimited': lambda: ' '.join(__import__('re').split(r'[-_\s]+', obj)), 'toUnderscoreDelimited': lambda: '_'.join(obj.split()), 'toPlusDelimited': lambda: '+'.join(obj.split()), 'toTildeDelimited': lambda: '~'.join(obj.split()), 'toEqualDelimited': lambda: '='.join(obj.split()), 'toHashDelimited': lambda: '#'.join(obj.split()), 'toAtDelimited': lambda: '@'.join(obj.split()), 'toCaretDelimited': lambda: '^'.join(obj.split()), 'toAmpersandDelimited': lambda: '&'.join(obj.split()), 'toExclamationDelimited': lambda: '!'.join(obj.split()), 'toQuestionDelimited': lambda: '?'.join(obj.split()), 'toSlashDelimited': lambda: '/'.join(obj.split()), 'toBackslashDelimited': lambda: '\\'.join(obj.split()), 'toDotDelimited': lambda: '.'.join(obj.split()), 'toArrowDelimited': lambda: '->'.join(obj.split()), 'toDoubleArrowDelimited': lambda: '=>'.join(obj.split()), 'toDoubleColonDelimited': lambda: '::'.join(obj.split()), 'toDoubleDashDelimited': lambda: '--'.join(obj.split()), 'toDoublePipeDelimited': lambda: '||'.join(obj.split()), 'toDoubleUnderscoreDelimited': lambda: '__'.join(obj.split()), 'toDoubleSlashDelimited': lambda: '//'.join(obj.split()), 'toDoubleHashDelimited': lambda: '##'.join(obj.split()), 'toDoubleAtDelimited': lambda: '@@'.join(obj.split()), 'toDoubleTildeDelimited': lambda: '~~'.join(obj.split()), 'toDoublePlusDelimited': lambda: '++'.join(obj.split()), 'toDoubleAmpersandDelimited': lambda: '&&'.join(obj.split()), 'toDoubleExclamationDelimited': lambda: '!!'.join(obj.split()), 'toDoubleQuestionDelimited': lambda: '??'.join(obj.split()), 'toTripleDashDelimited': lambda: '---'.join(obj.split()), 'toTripleDotDelimited': lambda: '...'.join(obj.split()), 'toTripleEqualDelimited': lambda: '==='.join(obj.split()), 'toTripleHashDelimited': lambda: '###'.join(obj.split()), 'toTriplePipeDelimited': lambda: '|||'.join(obj.split()), 'toTripleUnderscoreDelimited': lambda: '___'.join(obj.split()), 'toTripleStarDelimited': lambda: '***'.join(obj.split()), 'toTripleAtDelimited': lambda: '@@@'.join(obj.split()), 'toTripleCaretDelimited': lambda: '^^^'.join(obj.split()), 'toTripleAmpersandDelimited': lambda: '&&&'.join(obj.split()), 'toTripleExclamationDelimited': lambda: '!!!'.join(obj.split()), 'toTripleQuestionDelimited': lambda: '???'.join(obj.split()), 'toTripleSlashDelimited': lambda: '///'.join(obj.split()), 'toTripleTildeDelimited': lambda: '~~~'.join(obj.split()), 'toTriplePlusDelimited': lambda: '+++'.join(obj.split()), 'toTripleColonDelimited': lambda: ':::'.join(obj.split()), 'toTripleSemicolonDelimited': lambda: ';;;'.join(obj.split()), 'toTripleDollarDelimited': lambda: '$$$'.join(obj.split()), 'toTriplePercentDelimited': lambda: '%%%'.join(obj.split()), 'toTripleBacktickDelimited': lambda: '```'.join(obj.split()), 'toQuadDashDelimited': lambda: '----'.join(obj.split()), 'toQuadDotDelimited': lambda: '....'.join(obj.split()), 'toQuadEqualDelimited': lambda: '===='.join(obj.split()), 'toQuadPipeDelimited': lambda: '||||'.join(obj.split()), 'toQuadHashDelimited': lambda: '####'.join(obj.split()), 'toQuadStarDelimited': lambda: '****'.join(obj.split()), 'toQuadAtDelimited': lambda: '@@@@'.join(obj.split()), 'toQuadTildeDelimited': lambda: '~~~~'.join(obj.split()), 'toQuadUnderscoreDelimited': lambda: '____'.join(obj.split()), 'toQuadSlashDelimited': lambda: '////'.join(obj.split()), 'toQuadPlusDelimited': lambda: '++++'.join(obj.split()), 'toQuadColonDelimited': lambda: '::::'.join(obj.split()), 'toQuadSemicolonDelimited': lambda: ';;;;'.join(obj.split()), 'toQuadDollarDelimited': lambda: '$$$$'.join(obj.split()), 'toQuadPercentDelimited': lambda: '%%%%'.join(obj.split()), 'toQuadBacktickDelimited': lambda: '````'.join(obj.split()), 'toQuadAmpersandDelimited': lambda: '&&&&'.join(obj.split()), 'toQuadExclamationDelimited': lambda: '!!!!'.join(obj.split()), 'toQuadQuestionDelimited': lambda: '????'.join(obj.split()), 'toQuadCaretDelimited': lambda: '^^^^'.join(obj.split()), 'toQuintDashDelimited': lambda: '-----'.join(obj.split()), 'toQuintDotDelimited': lambda: '.....'.join(obj.split()), 'toQuintEqualDelimited': lambda: '====='.join(obj.split()), 'toQuintPipeDelimited': lambda: '|||||'.join(obj.split()), 'toQuintHashDelimited': lambda: '#####'.join(obj.split()), 'toQuintStarDelimited': lambda: '*****'.join(obj.split()), 'toQuintAtDelimited': lambda: '@@@@@'.join(obj.split()), 'toQuintCaretDelimited': lambda: '^^^^^'.join(obj.split()), 'toQuintAmpersandDelimited': lambda: '&&&&&'.join(obj.split()), 'toQuintExclamationDelimited': lambda: '!!!!!'.join(obj.split()), 'toQuintQuestionDelimited': lambda: '?????'.join(obj.split()), 'toQuintTildeDelimited': lambda: '~~~~~'.join(obj.split()), 'toQuintPlusDelimited': lambda: '+++++'.join(obj.split()), 'toQuintColonDelimited': lambda: ':::::'.join(obj.split()), 'toQuintSemicolonDelimited': lambda: ';;;;;'.join(obj.split()), 'toQuintDollarDelimited': lambda: '$$$$$'.join(obj.split()), 'toQuintPercentDelimited': lambda: '%%%%%'.join(obj.split()), 'toQuintBacktickDelimited': lambda: '`````'.join(obj.split()), 'toQuintUnderscoreDelimited': lambda: '_____'.join(obj.split()), 'toQuintSlashDelimited': lambda: '/////'.join(obj.split()), 'toSextDashDelimited': lambda: '------'.join(obj.split()), 'toSextDotDelimited': lambda: '......'.join(obj.split()), 'toSextEqualDelimited': lambda: '======'.join(obj.split()), 'toSextPipeDelimited': lambda: '||||||'.join(obj.split()), 'toSextHashDelimited': lambda: '######'.join(obj.split()), 'toSextStarDelimited': lambda: '******'.join(obj.split()), 'toSextAtDelimited': lambda: '@@@@@@'.join(obj.split()), 'toSextCaretDelimited': lambda: '^^^^^^'.join(obj.split()), 'toSextAmpersandDelimited': lambda: '&&&&&&'.join(obj.split()), 'toSextExclamationDelimited': lambda: '!!!!!!'.join(obj.split()), 'toSextQuestionDelimited': lambda: '??????'.join(obj.split()), 'toSextTildeDelimited': lambda: '~~~~~~'.join(obj.split()), 'toSextPlusDelimited': lambda: '++++++'.join(obj.split()), 'toSextColonDelimited': lambda: '::::::'.join(obj.split()), 'toSextSemicolonDelimited': lambda: ';;;;;;'.join(obj.split()), 'toSextDollarDelimited': lambda: '$$$$$$'.join(obj.split()), 'toSextPercentDelimited': lambda: '%%%%%%'.join(obj.split()), 'toSextBacktickDelimited': lambda: '``````'.join(obj.split()), 'toSextUnderscoreDelimited': lambda: '______'.join(obj.split()), 'toSextSlashDelimited': lambda: '//////'.join(obj.split()), 'toSeptDashDelimited': lambda: '-------'.join(obj.split()), 'toSeptDotDelimited': lambda: '.......'.join(obj.split()), 'toSeptEqualDelimited': lambda: '======='.join(obj.split()), 'toSeptPipeDelimited': lambda: '|||||||'.join(obj.split()), 'toSeptHashDelimited': lambda: '#######'.join(obj.split()), 'toSeptStarDelimited': lambda: '*******'.join(obj.split()), 'toSeptAtDelimited': lambda: '@@@@@@@'.join(obj.split()), 'toSeptCaretDelimited': lambda: '^^^^^^^'.join(obj.split()), 'toSeptAmpersandDelimited': lambda: '&&&&&&&'.join(obj.split()), 'toSeptExclamationDelimited': lambda: '!!!!!!!'.join(obj.split()), 'toSeptQuestionDelimited': lambda: '???????'.join(obj.split()), 'toSeptTildeDelimited': lambda: '~~~~~~~'.join(obj.split()), 'toSeptPlusDelimited': lambda: '+++++++'.join(obj.split()), 'toSeptColonDelimited': lambda: ':::::::'.join(obj.split()), 'toSeptSemicolonDelimited': lambda: ';;;;;;;'.join(obj.split()), 'toSeptDollarDelimited': lambda: '$$$$$$$'.join(obj.split()), 'toSeptPercentDelimited': lambda: '%%%%%%%'.join(obj.split()), 'toSeptBacktickDelimited': lambda: '```````'.join(obj.split()), 'toSeptUnderscoreDelimited': lambda: '_______'.join(obj.split()), 'toSeptSlashDelimited': lambda: '///////'.join(obj.split()), 'toOctDashDelimited': lambda: '--------'.join(obj.split()), 'toOctDotDelimited': lambda: '........'.join(obj.split()), 'toOctEqualDelimited': lambda: '========'.join(obj.split()), 'toOctPipeDelimited': lambda: '||||||||'.join(obj.split()), 'toOctHashDelimited': lambda: '########'.join(obj.split()), 'toOctStarDelimited': lambda: '********'.join(obj.split()), 'toOctAtDelimited': lambda: '@@@@@@@@'.join(obj.split()), 'toOctCaretDelimited': lambda: '^^^^^^^^'.join(obj.split()), 'toOctAmpersandDelimited': lambda: '&&&&&&&&'.join(obj.split()), 'toOctExclamationDelimited': lambda: '!!!!!!!!'.join(obj.split()), 'toOctQuestionDelimited': lambda: '????????'.join(obj.split()), 'toOctTildeDelimited': lambda: '~~~~~~~~'.join(obj.split()), 'toOctPlusDelimited': lambda: '++++++++'.join(obj.split()), 'toOctColonDelimited': lambda: '::::::::'.join(obj.split()), 'toOctSemicolonDelimited': lambda: ';;;;;;;;'.join(obj.split()), 'toOctDollarDelimited': lambda: '$$$$$$$$'.join(obj.split()), 'toOctPercentDelimited': lambda: '%%%%%%%%'.join(obj.split()), 'toOctBacktickDelimited': lambda: '````````'.join(obj.split()), 'toOctUnderscoreDelimited': lambda: '________'.join(obj.split()), 'toOctSlashDelimited': lambda: '////////'.join(obj.split()), 'toNonDashDelimited': lambda: '---------'.join(obj.split()), 'toNonDotDelimited': lambda: '.........'.join(obj.split()), 'toNonEqualDelimited': lambda: '========='.join(obj.split()), 'toNonPipeDelimited': lambda: '|||||||||'.join(obj.split()), 'toNonHashDelimited': lambda: '#########'.join(obj.split()), 'toNonStarDelimited': lambda: '*********'.join(obj.split()), 'toNonAtDelimited': lambda: '@@@@@@@@@'.join(obj.split()), 'toNonCaretDelimited': lambda: '^^^^^^^^^'.join(obj.split()), 'toNonAmpersandDelimited': lambda: '&&&&&&&&&'.join(obj.split()), 'toNonExclamationDelimited': lambda: '!!!!!!!!!'.join(obj.split()), 'toNonQuestionDelimited': lambda: '?????????'.join(obj.split()), 'toNonTildeDelimited': lambda: '~~~~~~~~~'.join(obj.split()), 'toNonPlusDelimited': lambda: '+++++++++'.join(obj.split()), 'toNonColonDelimited': lambda: ':::::::::'.join(obj.split()), 'toNonSemicolonDelimited': lambda: ';;;;;;;;;'.join(obj.split()), 'toNonDollarDelimited': lambda: '$$$$$$$$$'.join(obj.split()), 'toNonPercentDelimited': lambda: '%%%%%%%%%'.join(obj.split()), 'toNonBacktickDelimited': lambda: '`````````'.join(obj.split()), 'toNonUnderscoreDelimited': lambda: '_________'.join(obj.split()), 'toNonSlashDelimited': lambda: '/////////'.join(obj.split()), 'toDecDashDelimited': lambda: '----------'.join(obj.split()), 'toDecDotDelimited': lambda: '..........'.join(obj.split()), 'toDecEqualDelimited': lambda: '=========='.join(obj.split()), 'toDecPipeDelimited': lambda: '||||||||||'.join(obj.split()), 'toDecHashDelimited': lambda: '##########'.join(obj.split()), 'toDecStarDelimited': lambda: '**********'.join(obj.split()), 'toDecAtDelimited': lambda: '@@@@@@@@@@'.join(obj.split()), 'toDecCaretDelimited': lambda: '^^^^^^^^^^'.join(obj.split()), 'toDecAmpersandDelimited': lambda: '&&&&&&&&&&'.join(obj.split()), 'toDecExclamationDelimited': lambda: '!!!!!!!!!!'.join(obj.split()), 'toDecQuestionDelimited': lambda: '??????????'.join(obj.split()), 'toDecTildeDelimited': lambda: '~~~~~~~~~~'.join(obj.split()), 'toDecPlusDelimited': lambda: '++++++++++'.join(obj.split()), 'toDecColonDelimited': lambda: '::::::::::'.join(obj.split()), 'toDecSemicolonDelimited': lambda: ';;;;;;;;;;'.join(obj.split()), 'toDecDollarDelimited': lambda: '$$$$$$$$$$'.join(obj.split()), 'toDecPercentDelimited': lambda: '%%%%%%%%%%'.join(obj.split()), 'toDecBacktickDelimited': lambda: '``````````'.join(obj.split()), 'toDecUnderscoreDelimited': lambda: '__________'.join(obj.split()), 'toDecSlashDelimited': lambda: '//////////'.join(obj.split()), 'toUndecDashDelimited': lambda: '-----------'.join(obj.split()), 'toUndecDotDelimited': lambda: '...........'.join(obj.split()), 'toUndecEqualDelimited': lambda: '==========='.join(obj.split()), 'toUndecPipeDelimited': lambda: '|||||||||||'.join(obj.split()), 'toUndecHashDelimited': lambda: '###########'.join(obj.split()), 'toUndecStarDelimited': lambda: '***********'.join(obj.split()), 'toUndecAtDelimited': lambda: '@@@@@@@@@@@'.join(obj.split()), 'toUndecCaretDelimited': lambda: '^^^^^^^^^^^'.join(obj.split()), 'toUndecAmpersandDelimited': lambda: '&&&&&&&&&&&'.join(obj.split()), 'toUndecExclamationDelimited': lambda: '!!!!!!!!!!!'.join(obj.split()), 'toUndecQuestionDelimited': lambda: '???????????'.join(obj.split()), 'toUndecTildeDelimited': lambda: '~~~~~~~~~~~'.join(obj.split()), 'toUndecPlusDelimited': lambda: '+++++++++++'.join(obj.split()), 'toUndecColonDelimited': lambda: ':::::::::::'.join(obj.split()), 'toUndecSemicolonDelimited': lambda: ';;;;;;;;;;;'.join(obj.split()), 'toUndecDollarDelimited': lambda: '$$$$$$$$$$$'.join(obj.split()), 'toUndecPercentDelimited': lambda: '%%%%%%%%%%%'.join(obj.split()), 'toUndecBacktickDelimited': lambda: '```````````'.join(obj.split()), 'toUndecUnderscoreDelimited': lambda: '___________'.join(obj.split()), 'toUndecSlashDelimited': lambda: '///////////'.join(obj.split()), 'toDuodecDashDelimited': lambda: '------------'.join(obj.split()), 'toDuodecDotDelimited': lambda: '............'.join(obj.split()), 'toDuodecEqualDelimited': lambda: '============'.join(obj.split()), 'toDuodecPipeDelimited': lambda: '||||||||||||'.join(obj.split()), 'toDuodecHashDelimited': lambda: '############'.join(obj.split()), 'toDuodecStarDelimited': lambda: '************'.join(obj.split()), 'toDuodecAtDelimited': lambda: '@@@@@@@@@@@@'.join(obj.split()), 'toDuodecCaretDelimited': lambda: '^^^^^^^^^^^^'.join(obj.split()), 'toDuodecAmpersandDelimited': lambda: '&&&&&&&&&&&&'.join(obj.split()), 'toDuodecExclamationDelimited': lambda: '!!!!!!!!!!!!'.join(obj.split()), 'toDuodecQuestionDelimited': lambda: '????????????'.join(obj.split()), 'toDuodecTildeDelimited': lambda: '~~~~~~~~~~~~'.join(obj.split()), 'toDuodecPlusDelimited': lambda: '++++++++++++'.join(obj.split()), 'toDuodecColonDelimited': lambda: '::::::::::::'.join(obj.split()), 'toDuodecSemicolonDelimited': lambda: ';;;;;;;;;;;;'.join(obj.split()), 'toDuodecDollarDelimited': lambda: '$$$$$$$$$$$$'.join(obj.split()), 'toDuodecPercentDelimited': lambda: '%%%%%%%%%%%%'.join(obj.split()), 'toDuodecBacktickDelimited': lambda: '````````````'.join(obj.split()), 'toDuodecUnderscoreDelimited': lambda: '____________'.join(obj.split()), 'toDuodecSlashDelimited': lambda: '////////////'.join(obj.split()), 'toTredecDashDelimited': lambda: '-------------'.join(obj.split()), 'toTredecDotDelimited': lambda: '.............'.join(obj.split()), 'toTredecEqualDelimited': lambda: '============='.join(obj.split()), 'toTredecPipeDelimited': lambda: '|||||||||||||'.join(obj.split()), 'toTredecHashDelimited': lambda: '#############'.join(obj.split()), 'toTredecStarDelimited': lambda: '*************'.join(obj.split()), 'toTredecAtDelimited': lambda: '@@@@@@@@@@@@@'.join(obj.split()), 'toTredecCaretDelimited': lambda: '^^^^^^^^^^^^^'.join(obj.split()), 'toTredecAmpersandDelimited': lambda: '&&&&&&&&&&&&&'.join(obj.split()), 'toTredecExclamationDelimited': lambda: '!!!!!!!!!!!!!'.join(obj.split()), 'toTredecQuestionDelimited': lambda: '?????????????'.join(obj.split()), 'toTredecTildeDelimited': lambda: '~~~~~~~~~~~~~'.join(obj.split()), 'toTredecPlusDelimited': lambda: '+++++++++++++'.join(obj.split()), 'toTredecColonDelimited': lambda: ':::::::::::::'.join(obj.split()), 'toTredecSemicolonDelimited': lambda: ';;;;;;;;;;;;;'.join(obj.split()), 'toTredecDollarDelimited': lambda: '$$$$$$$$$$$$$'.join(obj.split()), 'toTredecPercentDelimited': lambda: '%%%%%%%%%%%%%'.join(obj.split()), 'toTredecBacktickDelimited': lambda: '`````````````'.join(obj.split()), 'toTredecUnderscoreDelimited': lambda: '_____________'.join(obj.split()),
     }
        if member == 'toMorse': member = 'toMorseCode'
        if member in _noarg:
            fn = _noarg[member]
            return ('builtin', lambda args, ctx: fn())
        # Single-arg methods
        _onearg = {
            'contains': lambda a: a[0] in obj, 'includes': lambda a: a[0] in obj,
            'starts_with': lambda a: obj.startswith(a[0]), 'ends_with': lambda a: obj.endswith(a[0]),
            'indexOf': lambda a: obj.find(a[0]), 'lastIndexOf': lambda a: obj.rfind(a[0]),
            'count': lambda a: obj.count(a[0]), 'split': lambda a: obj.split(a[0] if a else " "), 'repeat': lambda a: obj * int(a[0]),
            'charAt': lambda a: obj[int(a[0])], 'charCodeAt': lambda a: ord(obj[int(a[0])]), 'zfill': lambda a: obj.zfill(int(a[0])),
            'countWords': lambda a: obj.split().count(a[0]), 'isAnagram': lambda a: sorted(obj.lower().replace(' ', '')) == sorted(a[0].lower().replace(' ', '')),
            'indent': lambda a: '\n'.join(' ' * int(a[0]) + l for l in obj.split('\n')), 'surround': lambda a: a[0] + obj + a[0], 'removeAt': lambda a: obj[:int(a[0])] + obj[int(a[0])+1:],
            'wordWrap': lambda a: (lambda w, words: '\n'.join(lines) if (lines := __import__('functools').reduce(lambda acc, word: acc[:-1] + [acc[-1] + ' ' + word] if acc and len(acc[-1]) + 1 + len(word) <= w else acc + [word], words, [])) else '')(int(a[0]), obj.split()),
            'caesarCipher': lambda a: ''.join(chr((ord(c) - (65 if c.isupper() else 97) + int(a[0])) % 26 + (65 if c.isupper() else 97)) if c.isalpha() else c for c in obj),
            'vigenereCipher': lambda a: ''.join(chr((ord(c) - 97 + ord(a[0][i % len(a[0])].lower()) - 97) % 26 + 97) if c.isalpha() else c for i, c in enumerate(obj.lower())),
            'toColumnar': lambda a: ''.join(obj[i::int(a[0])] for i in range(int(a[0]))),
            'toCenterPad': lambda a: obj.center(int(a[0])),
            'toNGram': lambda a: [obj[i:i+int(a[0])] for i in range(len(obj)-int(a[0])+1)],
        }
        if member in _onearg:
            fn = _onearg[member]
            return ('builtin', lambda args, ctx: fn(args))
        if member == 'toRailFence':
            def _rf(args, ctx):
                n, r = int(args[0]), ['' for _ in range(int(args[0]))]
                row, d = 0, 1
                for c in obj:
                    r[row] += c; row += d
                    if row == 0 or row == n - 1: d = -d
                return ''.join(r)
            return ('builtin', _rf)
        # Two-arg methods
        _twoarg = {
            'replace': lambda a: obj.replace(a[0], a[1]),
            'replaceAll': lambda a: obj.replace(a[0], a[1]),
            'replaceFirst': lambda a: obj.replace(a[0], a[1], 1),
            'padStart': lambda a: obj.rjust(int(a[0]), a[1]),
            'padEnd': lambda a: obj.ljust(int(a[0]), a[1]),
            'center': lambda a: obj.center(int(a[0]), a[1]), 'centerPad': lambda a: obj.center(int(a[0]), a[1]),
            'wrap': lambda a: a[0] + obj + a[1],
            'mask': lambda a: a[0] * (len(obj) - int(a[1])) + obj[-int(a[1]):] if len(obj) > int(a[1]) else obj,
            'padCenter': lambda a: obj.center(int(a[0]), a[1]),
            'wrapEach': lambda a: ''.join(a[0] + c + a[1] for c in obj),
            'replaceAt': lambda a: obj[:int(a[0])] + a[1] + obj[int(a[0])+1:],
            'insertAt': lambda a: obj[:int(a[0])] + a[1] + obj[int(a[0]):],
        }
        if member in _twoarg:
            fn = _twoarg[member]
            return ('builtin', lambda args, ctx: fn(args))
        if member in ('substring', 'slice'):
            return ('builtin', lambda args, ctx: obj[int(args[0]):int(args[1])] if len(args) > 1 else obj[int(args[0]):])
        if member in ('toInt', 'toFloat'):
            def _conv(args, ctx):
                try: v = int(obj) if member == 'toInt' else float(obj); return v if member == 'toInt' or v != int(v) else int(v)
                except ValueError: raise RuntimeError_(f"Cannot convert '{obj}' to {'int' if member == 'toInt' else 'float'}")
            return ('builtin', _conv)
        if member == 'format':
            return ('builtin', lambda args, ctx: __import__('functools').reduce(lambda r, a: r.replace('{}', silk_repr(a), 1), args, obj))
        if member in ('removePrefix', 'removeSuffix'):
            return ('builtin', lambda args, ctx: (obj[len(args[0]):] if obj.startswith(args[0]) else obj) if member == 'removePrefix' else (obj[:-len(args[0])] if obj.endswith(args[0]) else obj))
        if member == 'truncate':
            return ('builtin', lambda args, ctx: obj if len(obj) <= int(args[0]) else obj[:int(args[0]) - len(args[1] if len(args) > 1 else '')] + (args[1] if len(args) > 1 else ''))
        if member == 'isNumeric':
            def _n(args, ctx):
                try: return bool(obj) and float(obj) is not None
                except ValueError: return False
            return ('builtin', _n)
        if member == 'squeeze': return ('builtin', lambda args, ctx: __import__('re').sub(r' {2,}', ' ', obj))
        if member == 'at': return ('builtin', lambda args, ctx: obj[int(args[0])] if -len(obj) <= int(args[0]) < len(obj) else None)
        if member in ('camelCase', 'snakeCase', 'kebabCase', 'titleCase', 'toPascalCase', 'toConstantCase', 'toDotCase', 'toPathCase', 'toTrainCase'):
            def _cc(args, ctx, _re=__import__('re')):
                p = [w for s in _re.split(r'[-_\s]+', obj) for w in _re.sub(r'([a-z])([A-Z])', r'\1_\2', s).split('_') if w]
                if member == 'camelCase': return p[0].lower() + ''.join(w.capitalize() for w in p[1:])
                if member in ('titleCase', 'toPascalCase', 'toTrainCase'): return (' ' if member == 'titleCase' else '-' if member == 'toTrainCase' else '').join(w.capitalize() for w in p)
                sep = {'snakeCase': '_', 'toConstantCase': '_', 'toDotCase': '.', 'toPathCase': '/'}.get(member, '-')
                r = _re.sub(r'([a-z])([A-Z])', r'\1' + sep + r'\2', _re.sub(r'[-_\s]+', sep, obj))
                return r.upper() if member == 'toConstantCase' else r.lower()
            return ('builtin', _cc)
        if member == 'truncateWords':
            return ('builtin', lambda args, ctx: obj if len(w := obj.split()) <= int(args[0]) else ' '.join(w[:int(args[0])]) + '...')
        if member == 'isEmail':
            return ('builtin', lambda args, ctx: len(p := obj.split('@')) == 2 and len(p[0]) > 0 and '.' in p[1])
        if member == 'partition':
            return ('builtin', lambda args, ctx: list(obj.partition(args[0])))
        if member in ('commonPrefix', 'commonSuffix'):
            return ('builtin', lambda args, ctx: (lambda p: (lambda a, b, i: obj[:i] if member == 'commonPrefix' else (obj[len(obj)-i:] if i else ''))(p[0], p[1], next((i for i in range(min(len(p[0]), len(p[1]))) if p[0][i] != p[1][i]), min(len(p[0]), len(p[1])))))((obj, args[0]) if member == 'commonPrefix' else (obj[::-1], args[0][::-1])))
        if member == 'levenshtein':
            def _lev(args, ctx):
                o, m, n = args[0], len(obj), len(args[0])
                if not m or not n: return m or n
                return __import__('functools').reduce(lambda p, i: (c := [i+1]+[0]*n) and [c.__setitem__(j, min(c[j-1]+1, p[j]+1, p[j-1]+(obj[i]!=o[j-1]))) for j in range(1, n+1)] and c, range(m), list(range(n+1)))[n]
            return ('builtin', _lev)
        if member == 'hamming':
            return ('builtin', lambda args, ctx: sum(a != b for a, b in zip(obj, args[0])))
        if member == 'soundex':
            return ('builtin', lambda args, ctx, _c={c: d for d, cs in enumerate('AEIOUYHW,BFPV,CGJKQSXZ,DT,L,MN,R'.split(',')) for c in cs}: '' if not obj else (__import__('functools').reduce(lambda rp, ch: ((rp[0]+str(cd), cd or rp[1]) if (cd := _c.get(ch.upper(), 0)) > 0 and cd != rp[1] else (rp[0], cd or rp[1])), obj[1:], (obj[0].upper(), _c.get(obj[0].upper(), 0)))[0] + '000')[:4])
        if member == 'isUrl':
            return ('builtin', lambda args, ctx: obj.startswith(('http://', 'https://')) and '.' in obj.split('//')[1])
        if member == 'caesar':
            return ('builtin', lambda args, ctx: ''.join(chr((ord(c) - (65 if c.isupper() else 97) + int(args[0])) % 26 + (65 if c.isupper() else 97)) if c.isalpha() else c for c in obj))
        if member == 'charFrequency':
            return ('builtin', lambda args, ctx: (lambda f: [f.update({c: f.get(c, 0) + 1}) for c in obj] and f or f)({}))
        if member == 'dedent':
            return ('builtin', lambda args, ctx: (lambda ls, m: '\n'.join(l[m:] for l in ls))(obj.split('\n'), min((len(l)-len(l.lstrip()) for l in obj.split('\n') if l.strip()), default=0)))
        if member in ('slugify', 'toTitleSlug'):
            import re as _re; return ('builtin', lambda args, ctx: _re.sub(r'-+', '-', _re.sub(r'[^a-z0-9]+', '-', obj.lower())).strip('-'))
        if member == 'isJSON':
            def _ij(args, ctx):
                try: json.loads(obj); return True
                except: return False
            return ('builtin', _ij)
        if member in ('encodeBase64', 'decodeBase64'): return ('builtin', lambda args, ctx: (__import__('base64').b64encode if member == 'encodeBase64' else __import__('base64').b64decode)(obj.encode()).decode())
        if member == 'matchCount': return ('builtin', lambda args, ctx: len(__import__('re').findall(args[0], obj)))
        if member == 'extractNumbers': return ('builtin', lambda args, ctx: [int(n) if n.isdigit() else float(n) for n in __import__('re').findall(r'-?\d+\.?\d*', obj)])
        if member == 'extractEmails': return ('builtin', lambda args, ctx: __import__('re').findall(r'[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}', obj))
        if member == 'extractUrls': return ('builtin', lambda args, ctx: __import__('re').findall(r'https?://[^\s]+', obj))
        if member == 'parseXML': return ('builtin', lambda args, ctx: dict(__import__('re').findall(r'<(\w+)>([^<]*)</\1>', obj)))
        if member == 'wordFrequency': return ('builtin', lambda args, ctx: (lambda f: [f.update({w: f.get(w, 0) + 1}) for w in obj.split()] and f or f)({}) if obj.strip() else {})
        if member == 'isBalanced': return ('builtin', lambda args, ctx, _m={')':'(',']':'[','}':'{'}: __import__('functools').reduce(lambda s, c: None if s is None else (s + [c] if c in '([{' else (None if not s or s.pop() != _m[c] else s) if c in _m else s), obj, []) == [])
        if member == 'isISBN': return ('builtin', lambda args, ctx: len(obj) == 10 and obj[:9].isdigit() and sum((10-i)*int(c) for i, c in enumerate(obj[:9])) % 11 == (11 - int(obj[9])) % 11 if obj[9].isdigit() else False)
        if member == 'occurrences': return ('builtin', lambda args, ctx: [i for i in range(len(obj)) if obj[i:i+len(args[0])] == args[0]])
        if member == 'isCreditCard': return ('builtin', lambda args, ctx: obj.isdigit() and len(obj) >= 13 and sum(int(d) for d in obj[-1::-2]) + sum(sum(divmod(2 * int(d), 10)) for d in obj[-2::-2]) == 0 if not obj.isdigit() else (sum(int(d) for d in obj[-1::-2]) + sum(sum(divmod(2 * int(d), 10)) for d in obj[-2::-2])) % 10 == 0)
        raise RuntimeError_(f"'str' has no member '{member}'")

    def _eval_number_member(self, obj: int | float, member: str) -> Any:
        """Evaluate member access on a number."""
        def _to_base(n, base, _d='0123456789abcdefghijklmnopqrstuvwxyz'):
            if n == 0: return '0'
            neg, n, r = n < 0, abs(n), []
            while n: r.append(_d[n % base]); n //= base
            return ('-' if neg else '') + ''.join(reversed(r))
        _simple = {
            'abs': lambda: abs(obj), 'floor': lambda: math.floor(obj), 'ceil': lambda: math.ceil(obj), 'round': lambda: round(obj),
            'toString': lambda: str(obj), 'sqrt': lambda: math.sqrt(obj),
            'isEven': lambda: int(obj) % 2 == 0, 'isOdd': lambda: int(obj) % 2 != 0,
            'isPositive': lambda: obj > 0, 'isNegative': lambda: obj < 0,
            'isZero': lambda: obj == 0, 'isInteger': lambda: isinstance(obj, int), 'isFloat': lambda: isinstance(obj, float), 'sign': lambda: (1 if obj > 0 else (-1 if obj < 0 else 0)),
            'toRadians': lambda: obj * math.pi / 180, 'toDegrees': lambda: obj * 180 / math.pi, 'factorial': lambda: math.factorial(int(obj)), 'toBinary': lambda: bin(int(obj))[2:],
            'toHex': lambda: hex(int(obj))[2:], 'toOctal': lambda: oct(int(obj))[2:], 'toChar': lambda: chr(int(obj)), 'digitSum': lambda: sum(int(d) for d in str(abs(int(obj)))), 'digitCount': lambda: len(str(abs(int(obj)))),
            'isPerfect': lambda: int(obj) > 1 and sum(i for i in range(1, int(obj)) if int(obj) % i == 0) == int(obj), 'toScientific': lambda: f"{obj:.1e}", 'factors': lambda: sorted(i for i in range(1, int(obj) + 1) if int(obj) % i == 0),
            'divisorCount': lambda: sum(1 for i in range(1, int(obj) + 1) if int(obj) % i == 0), 'digitalRoot': lambda: 0 if obj == 0 else 1 + (int(obj) - 1) % 9, 'isHarshad': lambda: int(obj) > 0 and int(obj) % sum(int(d) for d in str(int(obj))) == 0,
            'sumTo': lambda: int(obj) * (int(obj) + 1) // 2, 'aliquotSum': lambda: sum(i for i in range(1, int(obj)) if int(obj) % i == 0),
            'isAutomorphic': lambda: str(int(obj) ** 2).endswith(str(int(obj))), 'toBits': lambda: [int(b) for b in bin(int(obj))[2:]], 'isKaprekar': lambda: (lambda n, sq: any(int(str(sq)[:i]) + int(str(sq)[i:]) == n for i in range(1, len(str(sq)))) if n > 0 else False)(int(obj), int(obj) ** 2),
            'cubeRoot': lambda: (lambda r: int(r) if r == int(r) else r)(round(obj ** (1/3), 10)), 'isAbundant': lambda: sum(i for i in range(1, int(obj)) if int(obj) % i == 0) > int(obj), 'isDeficient': lambda: sum(i for i in range(1, int(obj)) if int(obj) % i == 0) < int(obj),
            'isPowerOfTwo': lambda: int(obj) > 0 and (int(obj) & (int(obj) - 1)) == 0, 'sumOfSquares': lambda: sum(i * i for i in range(1, int(obj) + 1)), 'isNarcissistic': lambda: (lambda s, n: sum(int(d) ** n for d in s) == int(obj))(str(abs(int(obj))), len(str(abs(int(obj))))),
            'isSquare': lambda: int(obj) >= 0 and int(obj ** 0.5) ** 2 == int(obj), 'isCube': lambda: round(abs(int(obj)) ** (1/3)) ** 3 == abs(int(obj)),
            'isMersennePrime': lambda: (lambda n: n > 1 and (n + 1) & n == 0 and all(n % i for i in range(2, int(n**0.5) + 1)))(int(obj)), 'isTriangular': lambda: (lambda n: int((8*n+1)**0.5)**2 == 8*n+1)(int(obj)),
            'totient': lambda: sum(1 for i in range(1, int(obj) + 1) if math.gcd(i, int(obj)) == 1), 'harmonicSum': lambda: (lambda r: int(r) if r == int(r) else r)(sum(1/i for i in range(1, int(obj) + 1))),
            'isPronic': lambda: (lambda k: k * (k + 1) == int(obj))(int(int(obj) ** 0.5)),
            'digitProduct': lambda: __import__('functools').reduce(lambda a, b: a * b, (int(d) for d in str(abs(int(obj))))), 'reverseDigits': lambda: int(str(abs(int(obj)))[::-1]) * (1 if int(obj) >= 0 else -1), 'digitReverse': lambda: int(str(abs(int(obj)))[::-1]) * (1 if int(obj) >= 0 else -1),
            'isSmith': lambda: (lambda n, ds, pf: n > 1 and not all(n % i for i in range(2, int(n**0.5)+1)) and ds(n) == sum(ds(p) for p in pf(n)))(int(obj), lambda x: sum(int(d) for d in str(x)), lambda n: (f := lambda n, d: [] if n <= 1 else [d] + f(n//d, d) if n % d == 0 else f(n, d+1))(n, 2)), 'abundantBy': lambda: sum(i for i in range(1, int(obj)) if int(obj) % i == 0) - int(obj), 'abundance': lambda: sum(i for i in range(1, int(obj)) if int(obj) % i == 0) - int(obj),
            'isUntouchable': lambda: (lambda n: not any(sum(i for i in range(1, k) if k % i == 0) == n for k in range(2, 2*n+2)))(int(obj)), 'isSphenic': lambda: (lambda n, pf: len(pf) == 3 and len(set(pf)) == 3)((n := int(obj)), (f := lambda n, d: [] if n <= 1 else [d] + f(n//d, d) if n % d == 0 else f(n, d+1))(n, 2)), 'isSemiPrime': lambda: (lambda pf: len(pf) == 2)((f := lambda n, d: [] if n <= 1 else [d] + f(n//d, d) if n % d == 0 else f(n, d+1))(int(obj), 2)), 'isEmirp': lambda: (lambda n, ip: ip(n) and (r := int(str(n)[::-1])) != n and ip(r))(int(obj), lambda n: n >= 2 and all(n % i for i in range(2, int(n**0.5)+1))), 'pentagonal': lambda: int(obj) * (3 * int(obj) - 1) // 2, 'hexagonal': lambda: int(obj) * (2 * int(obj) - 1),
            'catalan': lambda: math.factorial(2 * int(obj)) // (math.factorial(int(obj) + 1) * math.factorial(int(obj))), 'bell': lambda: __import__('functools').reduce(lambda r, _: (s := [r[-1]]) and [s.append(s[-1]+v) for v in r] and s, range(int(obj)), [1])[0], 'derangements': lambda: round(math.factorial(int(obj)) * sum((-1)**k / math.factorial(k) for k in range(int(obj)+1))),
            'motzkin': lambda: __import__('functools').reduce(lambda ab, i: (ab[1], ((2*i+1)*ab[1] + 3*(i-1)*ab[0]) // (i+2)), range(1, int(obj)+1), (1, 1))[1] if int(obj) > 0 else 1,
            'tetrahedral': lambda: int(obj) * (int(obj) + 1) * (int(obj) + 2) // 6, 'pyramidal': lambda: int(obj) * (int(obj) + 1) * (2 * int(obj) + 1) // 6, 'star': lambda: 6 * int(obj) * (int(obj) - 1) + 1, 'oblong': lambda: int(obj) * (int(obj) + 1), 'pronic': lambda: int(obj) * (int(obj) + 1),
            'superFactorial': lambda: __import__('functools').reduce(lambda a, i: a * math.factorial(i), range(1, int(obj) + 1), 1), 'subfactorial': lambda: round(math.factorial(int(obj)) * sum((-1)**k / math.factorial(k) for k in range(int(obj)+1))), 'doubleFactorial': lambda: __import__('functools').reduce(lambda a, b: a * b, range(int(obj), 0, -2), 1),
            'primorial': lambda: __import__('functools').reduce(lambda a, b: a * b, [p for p in range(2, int(obj)+1) if all(p % i for i in range(2, int(p**0.5)+1))], 1), 'isLucky': lambda: (lambda n: (s := list(range(1, max(n*2, 10), 2))) and all((s := [s[j] for j in range(len(s)) if (j+1) % s[i] != 0]) or True for i in range(1, len(s)) if i < len(s) and s[i] <= len(s)) and n in s)(int(obj)),
            'isWieferich': lambda: (lambda n: n >= 2 and all(n % i for i in range(2, int(n**0.5)+1)) and pow(2, n-1, n*n) == 1)(int(obj)), 'isProth': lambda: (lambda n: n > 1 and any(n == k * (1 << e) + 1 and k < (1 << e) and k % 2 == 1 for e in range(1, n.bit_length()) for k in [((n-1) >> e)]))(int(obj)),
            'isHarmonious': lambda: (lambda n, d: n > 0 and (n * d) % sum(n // i for i in range(1, n+1) if n % i == 0) == 0)(int(obj), sum(1 for i in range(1, int(obj)+1) if int(obj) % i == 0)), 'sigma': lambda: sum(i for i in range(1, int(obj) + 1) if int(obj) % i == 0), 'divisorSum': lambda: sum(i for i in range(1, int(obj) + 1) if int(obj) % i == 0),
            'mobius': lambda: (lambda n, pf: 0 if len(pf) != len(set(pf)) else (-1)**len(pf))(int(obj), (f := lambda n, d: [] if n <= 1 else [d] + f(n//d, d) if n % d == 0 else f(n, d+1))(int(obj), 2)),
            'liouville': lambda: (-1)**len((f := lambda n, d: [] if n <= 1 else [d] + f(n//d, d) if n % d == 0 else f(n, d+1))(int(obj), 2)),
            'radical': lambda: __import__('functools').reduce(lambda a, b: a * b, set((f := lambda n, d: [] if n <= 1 else [d] + f(n//d, d) if n % d == 0 else f(n, d+1))(int(obj), 2)), 1),
            'omega': lambda: len(set((f := lambda n, d: [] if n <= 1 else [d] + f(n//d, d) if n % d == 0 else f(n, d+1))(int(obj), 2))), 'bigOmega': lambda: len((f := lambda n, d: [] if n <= 1 else [d] + f(n//d, d) if n % d == 0 else f(n, d+1))(int(obj), 2)),
            'isRegular': lambda: (lambda n, pf: n >= 1 and all(p in (2,3,5) for p in set(pf)))(int(obj), (lambda f, n: f(f, n, 2))(lambda s, n, d: [] if n <= 1 else [d] + s(s, n//d, d) if n % d == 0 else s(s, n, d+1), int(obj))),
            'isSquareFree': lambda: (lambda n: n >= 1 and all(n % (i*i) != 0 for i in range(2, int(n**0.5)+1)))(int(obj)),
            'isPractical': lambda: (lambda n: n >= 1 and (lambda ds: all(k <= 1 + sum(d for d in ds if d <= k) for k in range(1, n+1)))([i for i in range(1, n) if n % i == 0]))(int(obj)),
            'isHumble': lambda: (lambda n, pf: n >= 1 and all(p in (2,3,5,7) for p in set(pf)))(int(obj), (lambda f, n: f(f, n, 2))(lambda s, n, d: [] if n <= 1 else [d] + s(s, n//d, d) if n % d == 0 else s(s, n, d+1), int(obj))),
            'isSophieGermain': lambda: (lambda n, ip: ip(n) and ip(2*n+1))(int(obj), lambda n: n >= 2 and all(n % i for i in range(2, int(n**0.5)+1))),
            'isChen': lambda: (lambda n, ip, isp: ip(n) and (ip(n+2) or isp(n+2)))(int(obj), lambda n: n >= 2 and all(n % i for i in range(2, int(n**0.5)+1)), lambda n: len((f := lambda n, d: [] if n <= 1 else [d] + f(n//d, d) if n % d == 0 else f(n, d+1))(n, 2)) == 2),
            'isWasteful': lambda: (lambda n, pf: sum(len(str(p)) for p in pf) > len(str(n)))(int(obj), (lambda f, n: f(f, n, 2))(lambda s, n, d: [] if n <= 1 else [d] + s(s, n//d, d) if n % d == 0 else s(s, n, d+1), int(obj))),
            'isFrugal': lambda: (lambda n, pf: n > 1 and (lambda pe: sum(len(str(p)) + (len(str(e)) if e > 1 else 0) for p, e in pe) < len(str(n)))({p: pf.count(p) for p in set(pf)}.items()))(int(obj), (lambda f, n: f(f, n, 2))(lambda s, n, d: [] if n <= 1 else [d] + s(s, n//d, d) if n % d == 0 else s(s, n, d+1), int(obj))),
            'isEquidigital': lambda: (lambda n, pf: n > 1 and (lambda pe: sum(len(str(p)) + (len(str(e)) if e > 1 else 0) for p, e in pe) == len(str(n)))({p: pf.count(p) for p in set(pf)}.items()))(int(obj), (lambda f, n: f(f, n, 2))(lambda s, n, d: [] if n <= 1 else [d] + s(s, n//d, d) if n % d == 0 else s(s, n, d+1), int(obj))),
            'isSelfDescribing': lambda: (lambda s: all(int(s[i]) == s.count(str(i)) for i in range(len(s))))(str(int(obj))),
            'isTetrahedral': lambda: (lambda n: any(k*(k+1)*(k+2)//6 == n for k in range(int(n**(1/3))+3)))(int(obj)),
            'isOre': lambda: (lambda n, ds: len(ds) * n % sum(ds) == 0)(int(obj), [i for i in range(1, int(obj)+1) if int(obj) % i == 0]),
            'isPyramidal': lambda: (lambda n: any(k*(k+1)*(2*k+1)//6 == n for k in range(int((6*n)**(1/3))+2)))(int(obj)),
            'isStarNumber': lambda: (lambda n: n == 1 or (n > 0 and (n-1) % 6 == 0 and (lambda d: int(d**0.5)**2 == d)(1 + 4*((n-1)//6))))(int(obj)),
            'isCenteredSquare': lambda: (lambda n: n == 1 or (n > 0 and (n-1) % 2 == 0 and (lambda d: int(d**0.5)**2 == d)(1 + 4*((n-1)//2))))(int(obj)),
            'isCenteredHex': lambda: (lambda n: n == 1 or (n > 0 and (n-1) % 3 == 0 and (lambda d: int(d**0.5)**2 == d)(1 + 4*((n-1)//3))))(int(obj)),
            'isCenteredTriangular': lambda: (lambda n: n == 1 or (n > 0 and 2*(n-1) % 3 == 0 and (lambda d: int(d**0.5)**2 == d)(1 + 4*(2*(n-1)//3))))(int(obj)),
            'isDecagonal': lambda: (lambda n, d: d >= 0 and int(d**0.5)**2 == d and (3+int(d**0.5)) % 8 == 0)(int(obj), 9+16*int(obj)),
            'isHeptagonal': lambda: (lambda n, d: d >= 0 and int(d**0.5)**2 == d and (3+int(d**0.5)) % 10 == 0)(int(obj), 9+40*int(obj)),
            'isOctagonal': lambda: (lambda n, d: d >= 0 and int(d**0.5)**2 == d and (2+int(d**0.5)) % 6 == 0)(int(obj), 4+12*int(obj)),
            'isNonagonal': lambda: (lambda n, d: d >= 0 and int(d**0.5)**2 == d and (5+int(d**0.5)) % 14 == 0)(int(obj), 25+56*int(obj)),
            'isPowerful': lambda: (lambda n: n > 0 and any(n % (b**3) == 0 and int((n//(b**3))**0.5)**2 == n//(b**3) for b in range(1, int(n**(1/3))+2)))(int(obj)),
            'isAchilles': lambda: (lambda n: n > 1 and any(n % (b**3) == 0 and int((n//(b**3))**0.5)**2 == n//(b**3) for b in range(1, int(n**(1/3))+2)) and not any(round(n**(1/k)) ** k == n for k in range(2, int(n.bit_length())+1)))(int(obj)),
            'isTruncatablePrime': lambda: (lambda n: n > 1 and all((lambda m: m > 1 and all(m % i != 0 for i in range(2, int(m**0.5)+1)))(int(str(n)[:i])) for i in range(1, len(str(n))+1)))(int(obj)),
            'isCircularPrime': lambda: (lambda n, s: n > 1 and all((lambda m: m > 1 and all(m % i != 0 for i in range(2, int(m**0.5)+1)))(int(s[r:] + s[:r])) for r in range(len(s))))(int(obj), str(int(obj))),
            'isLeftTruncatablePrime': lambda: (lambda n: n > 1 and all((lambda m: m > 1 and all(m % i != 0 for i in range(2, int(m**0.5)+1)))(int(str(n)[i:])) for i in range(len(str(n)))))(int(obj)),
            'isKeith': lambda: (lambda n, ds: (lambda f: f(f, ds))((lambda f, s: True if s[-1] == n else False if s[-1] > n else f(f, s[1:] + [sum(s)]))))(int(obj), [int(d) for d in str(abs(int(obj)))]),
            'nearestPrime': lambda: (lambda n, ip: n if ip(n) else min((p for d in range(1, n) for p in (n-d, n+d) if p >= 2 and ip(p)), key=lambda p: (abs(p-n), p)))(int(obj), lambda n: n >= 2 and all(n % i for i in range(2, int(n**0.5)+1))),
            'digitPower': lambda: sum(int(d) ** (i+1) for i, d in enumerate(str(abs(int(obj))))),
            'digitRotateSum': lambda: (lambda s: sum(int(s[i:] + s[:i]) for i in range(len(s))))(str(int(obj))),
            'isPerfectSquareDigitSum': lambda: (lambda ds: int(ds**0.5)**2 == ds)(sum(int(d) for d in str(abs(int(obj))))),
            'coprimesUpTo': lambda: [i for i in range(1, int(obj)) if math.gcd(i, int(obj)) == 1],
            'digitFrequency': lambda: (lambda f: [f.update({int(d): f.get(int(d), 0) + 1}) for d in str(abs(int(obj)))] and f or f)({}),
            'digitGap': lambda: (lambda ds: max(abs(ds[i+1]-ds[i]) for i in range(len(ds)-1)))([int(d) for d in str(abs(int(obj)))]),
            'digitSort': lambda: int(''.join(sorted(str(abs(int(obj)))))),
            'digitSortDesc': lambda: int(''.join(sorted(str(abs(int(obj))), reverse=True))),
            'digitMirror': lambda: int(str(abs(int(obj))) + str(abs(int(obj)))[::-1]), 'digitMin': lambda: min(int(d) for d in str(abs(int(obj)))), 'digitMax': lambda: max(int(d) for d in str(abs(int(obj)))), 'digitDistinct': lambda: len(set(str(abs(int(obj))))),
            'digitMedian': lambda: (lambda ds, n: ds[n//2] if n % 2 else (lambda m: int(m) if m == int(m) else m)((ds[n//2-1]+ds[n//2])/2))(sorted(int(d) for d in str(abs(int(obj)))), len(str(abs(int(obj))))),
            'digitAverage': lambda: (lambda ds: (lambda s, n: int(s/n) if s/n == int(s/n) else s/n)(sum(ds), len(ds)))([int(d) for d in str(abs(int(obj)))]), 'digitRange': lambda: (lambda ds: max(ds) - min(ds))([int(d) for d in str(abs(int(obj)))]), 'digitPairs': lambda: (lambda ds: [[ds[i], ds[i+1]] for i in range(len(ds)-1)])([int(d) for d in str(abs(int(obj)))]), 'digitCumSum': lambda: (lambda ds: [sum(ds[:i+1]) for i in range(len(ds))])([int(d) for d in str(abs(int(obj)))]), 'digitCumProduct': lambda: (lambda ds: list(__import__('itertools').accumulate(ds, lambda a, b: a * b)))([int(d) for d in str(abs(int(obj)))]), 'digitRunLengths': lambda: [[int(k), sum(1 for _ in g)] for k, g in __import__('itertools').groupby(str(abs(int(obj))))], 'digitWeightedSum': lambda: sum(int(d) * (i+1) for i, d in enumerate(str(abs(int(obj))))), 'digitAlternatingSum': lambda: sum(int(d) * (1 if i % 2 == 0 else -1) for i, d in enumerate(str(abs(int(obj))))), 'digitSquareSum': lambda: sum(int(d) ** 2 for d in str(abs(int(obj)))), 'digitCubeSum': lambda: sum(int(d) ** 3 for d in str(abs(int(obj)))), 'digitPowerSum': lambda: sum(int(d) ** int(d) if int(d) > 0 else 0 for d in str(abs(int(obj)))), 'digitEntropy': lambda: (lambda ds, n: (lambda ps: (lambda e: int(e) if e == int(e) else round(e, 10))(-sum(p * __import__('math').log2(p) for p in ps if p > 0)))([ds.count(d)/n for d in set(ds)]))(list(str(abs(int(obj)))), len(str(abs(int(obj))))), 'digitHistogram': lambda: sorted([[int(d), list(str(abs(int(obj)))).count(d)] for d in set(str(abs(int(obj))))]), 'digitModeValue': lambda: int(max(set(str(abs(int(obj)))), key=lambda d: str(abs(int(obj))).count(d))), 'digitIsAscending': lambda: all(int(str(abs(int(obj)))[i]) <= int(str(abs(int(obj)))[i+1]) for i in range(len(str(abs(int(obj))))-1)), 'digitIsDescending': lambda: all(int(str(abs(int(obj)))[i]) >= int(str(abs(int(obj)))[i+1]) for i in range(len(str(abs(int(obj))))-1)), 'digitIsPalindrome': lambda: str(abs(int(obj))) == str(abs(int(obj)))[::-1], 'digitIsAllEven': lambda: all(int(d) % 2 == 0 for d in str(abs(int(obj)))), 'digitIsAllOdd': lambda: all(int(d) % 2 != 0 for d in str(abs(int(obj)))), 'digitIsStrictlyIncreasing': lambda: all(int(str(abs(int(obj)))[i]) < int(str(abs(int(obj)))[i+1]) for i in range(len(str(abs(int(obj))))-1)), 'digitIsStrictlyDecreasing': lambda: all(int(str(abs(int(obj)))[i]) > int(str(abs(int(obj)))[i+1]) for i in range(len(str(abs(int(obj))))-1)), 'digitIsAlternating': lambda: all(int(d) % 2 != int(str(abs(int(obj)))[i+1]) % 2 for i, d in enumerate(str(abs(int(obj)))[:-1])), 'digitHasRepeats': lambda: len(set(str(abs(int(obj))))) < len(str(abs(int(obj)))), 'digitHasZero': lambda: '0' in str(abs(int(obj))), 'digitAllDistinct': lambda: len(set(str(abs(int(obj))))) == len(str(abs(int(obj)))), 'digitIsMonotonic': lambda: len(set(str(abs(int(obj))))) == 1, 'digitMiddle': lambda: int(str(abs(int(obj)))[len(str(abs(int(obj))))//2]), 'digitFirst': lambda: int(str(abs(int(obj)))[0]), 'digitLast': lambda: int(str(abs(int(obj)))[-1]), 'digitRotateLeft': lambda: (lambda s: int(s[1:] + s[0]))(str(abs(int(obj)))), 'digitRotateRight': lambda: (lambda s: int(s[-1] + s[:-1]))(str(abs(int(obj)))), 'digitSwapFirstLast': lambda: (lambda s: int(s[-1] + s[1:-1] + s[0]) if len(s) > 1 else int(s))(str(abs(int(obj)))), 'digitGCD': lambda: __import__('functools').reduce(__import__('math').gcd, [int(d) for d in str(abs(int(obj)))]), 'digitLCM': lambda: __import__('functools').reduce(lambda a, b: a * b // __import__('math').gcd(a, b), [int(d) for d in str(abs(int(obj))) if d != '0']), 'digitRMS': lambda: (lambda ds: __import__('math').sqrt(sum(d**2 for d in ds)/len(ds)))([int(d) for d in str(abs(int(obj)))]), 'digitHarmonicMean': lambda: (lambda ds: (lambda r: int(r) if r == int(r) else r)(len(ds) / sum(1/d for d in ds if d != 0)))([int(d) for d in str(abs(int(obj)))]), 'digitMean': lambda: (lambda ds: (lambda r: int(r) if r == int(r) else r)(sum(ds) / len(ds)))([int(d) for d in str(abs(int(obj)))]), 'digitGeometricMean': lambda: (lambda ds: (lambda r: int(r) if r == int(r) else r)(__import__('functools').reduce(lambda a, b: a * b, ds) ** (1/len(ds))))([int(d) for d in str(abs(int(obj)))]), 'digitVariance': lambda: (lambda ds: (lambda m: (lambda v: int(v) if v == int(v) else v)(sum((d - m) ** 2 for d in ds) / len(ds)))(sum(ds) / len(ds)))([int(d) for d in str(abs(int(obj)))]), 'digitStdDev': lambda: (lambda ds: (lambda m: (lambda v: int(v) if v == int(v) else v)(__import__('math').sqrt(sum((d - m) ** 2 for d in ds) / len(ds))))(sum(ds) / len(ds)))([int(d) for d in str(abs(int(obj)))]), 'digitMedianAbsDev': lambda: (lambda ds: (lambda md: (lambda devs: (lambda n: devs[n//2] if n % 2 else (lambda r: int(r) if r == int(r) else r)((devs[n//2-1]+devs[n//2])/2))(len(devs)))(sorted(abs(d - md) for d in ds)))((lambda n: ds[n//2] if n % 2 else (ds[n//2-1]+ds[n//2])//2)(len(ds))))(sorted(int(d) for d in str(abs(int(obj))))), 'digitSkewness': lambda: (lambda ds: (lambda m, s: (lambda sk: int(sk) if sk == int(sk) else sk)(sum((d - m) ** 3 for d in ds) / (len(ds) * s ** 3)) if s != 0 else 0)(sum(ds)/len(ds), __import__('math').sqrt(sum((d - sum(ds)/len(ds))**2 for d in ds)/len(ds))))([int(d) for d in str(abs(int(obj)))]), 'digitKurtosis': lambda: (lambda ds: (lambda m, s: (lambda k: int(k) if k == int(k) else k)(sum((d - m) ** 4 for d in ds) / (len(ds) * s ** 4)) if s != 0 else 0)(sum(ds)/len(ds), __import__('math').sqrt(sum((d - sum(ds)/len(ds))**2 for d in ds)/len(ds))))([int(d) for d in str(abs(int(obj)))]), 'digitCoeffVar': lambda: (lambda ds: (lambda m, s: (lambda cv: int(cv) if cv == int(cv) else cv)(s / m) if m != 0 else 0)(sum(ds)/len(ds), __import__('math').sqrt(sum((d - sum(ds)/len(ds))**2 for d in ds)/len(ds))))([int(d) for d in str(abs(int(obj)))]), 'digitInterquartileRange': lambda: (lambda ds: (lambda n: (lambda q1, q3: (lambda r: int(r) if r == int(r) else r)(q3 - q1))((lambda h: ds[h//2] if h % 2 else (ds[h//2-1]+ds[h//2])/2)(n//2), (lambda h, off: ds[off+h//2] if h % 2 else (ds[off+h//2-1]+ds[off+h//2])/2)((n+1)//2, n//2)))(len(ds)))(sorted(int(d) for d in str(abs(int(obj))))), 'digitTrimmedMean': lambda: (lambda ds: (lambda trimmed: (lambda r: int(r) if r == int(r) else r)(sum(trimmed)/len(trimmed)) if trimmed else ds[0])(sorted(ds)[1:-1]))(list(int(d) for d in str(abs(int(obj))))), 'digitWinsorizedMean': lambda: (lambda ds: (lambda s: (lambda r: int(r) if r == int(r) else r)(sum([s[1]] + s[1:-1] + [s[-2]] if len(s) > 2 else s) / len(s)))(sorted(ds)))(list(int(d) for d in str(abs(int(obj))))), 'digitMidrange': lambda: (lambda ds: (lambda r: int(r) if r == int(r) else r)((min(ds) + max(ds)) / 2))([int(d) for d in str(abs(int(obj)))]), 'digitCountEven': lambda: sum(1 for d in str(abs(int(obj))) if int(d) % 2 == 0), 'digitCountOdd': lambda: sum(1 for d in str(abs(int(obj))) if int(d) % 2 != 0), 'digitCountZero': lambda: str(abs(int(obj))).count('0'), 'digitCountNonZero': lambda: sum(1 for d in str(abs(int(obj))) if d != '0'), 'digitSumEven': lambda: sum(int(d) for d in str(abs(int(obj))) if int(d) % 2 == 0), 'digitSumOdd': lambda: sum(int(d) for d in str(abs(int(obj))) if int(d) % 2 != 0), 'digitProductEven': lambda: (lambda evens: __import__('functools').reduce(lambda a, b: a * b, evens) if evens else 0)([int(d) for d in str(abs(int(obj))) if int(d) % 2 == 0]), 'digitProductOdd': lambda: (lambda odds: __import__('functools').reduce(lambda a, b: a * b, odds) if odds else 0)([int(d) for d in str(abs(int(obj))) if int(d) % 2 != 0]), 'digitMaxEven': lambda: max((int(d) for d in str(abs(int(obj))) if int(d) % 2 == 0), default=0), 'digitMinEven': lambda: min((int(d) for d in str(abs(int(obj))) if int(d) % 2 == 0), default=0), 'digitMaxOdd': lambda: max((int(d) for d in str(abs(int(obj))) if int(d) % 2 != 0), default=0), 'digitMinOdd': lambda: min((int(d) for d in str(abs(int(obj))) if int(d) % 2 != 0), default=0), 'digitSumSquares': lambda: sum(int(d) ** 2 for d in str(abs(int(obj)))), 'digitSumCubes': lambda: sum(int(d) ** 3 for d in str(abs(int(obj)))), 'digitAdjacentSum': lambda: (lambda ds: [ds[i] + ds[i+1] for i in range(len(ds)-1)])([int(d) for d in str(abs(int(obj)))]), 'digitAdjacentProduct': lambda: (lambda ds: [ds[i] * ds[i+1] for i in range(len(ds)-1)])([int(d) for d in str(abs(int(obj)))]), 'digitAdjacentDiff': lambda: (lambda ds: [abs(ds[i] - ds[i+1]) for i in range(len(ds)-1)])([int(d) for d in str(abs(int(obj)))]), 'digitAdjacentMax': lambda: (lambda ds: [max(ds[i], ds[i+1]) for i in range(len(ds)-1)])([int(d) for d in str(abs(int(obj)))]), 'digitAdjacentMin': lambda: (lambda ds: [min(ds[i], ds[i+1]) for i in range(len(ds)-1)])([int(d) for d in str(abs(int(obj)))]), 'digitAdjacentAvg': lambda: (lambda ds: [(lambda r: int(r) if r == int(r) else r)((ds[i]+ds[i+1])/2) for i in range(len(ds)-1)])([int(d) for d in str(abs(int(obj)))]), 'digitAdjacentGCD': lambda: (lambda ds: [__import__('math').gcd(ds[i], ds[i+1]) for i in range(len(ds)-1)])([int(d) for d in str(abs(int(obj)))]), 'digitAdjacentLCM': lambda: (lambda ds: [ds[i] * ds[i+1] // __import__('math').gcd(ds[i], ds[i+1]) if ds[i] and ds[i+1] else 0 for i in range(len(ds)-1)])([int(d) for d in str(abs(int(obj)))]), 'digitAdjacentParity': lambda: (lambda ds: [ds[i] % 2 == ds[i+1] % 2 for i in range(len(ds)-1)])([int(d) for d in str(abs(int(obj)))]), 'digitAdjacentRatio': lambda: (lambda ds: [(lambda r: int(r) if r == int(r) else r)(ds[i]/ds[i+1]) if ds[i+1] != 0 else 0 for i in range(len(ds)-1)])([int(d) for d in str(abs(int(obj)))]), 'digitAdjacentModulo': lambda: (lambda ds: [ds[i] % ds[i+1] if ds[i+1] != 0 else 0 for i in range(len(ds)-1)])([int(d) for d in str(abs(int(obj)))]), 'digitAdjacentPower': lambda: (lambda ds: [ds[i] ** ds[i+1] for i in range(len(ds)-1)])([int(d) for d in str(abs(int(obj)))]), 'digitWindowSum3': lambda: (lambda ds: [sum(ds[i:i+3]) for i in range(len(ds)-2)])([int(d) for d in str(abs(int(obj)))]), 'digitWindowMax3': lambda: (lambda ds: [max(ds[i:i+3]) for i in range(len(ds)-2)])([int(d) for d in str(abs(int(obj)))]), 'digitWindowMin3': lambda: (lambda ds: [min(ds[i:i+3]) for i in range(len(ds)-2)])([int(d) for d in str(abs(int(obj)))]), 'digitWindowAvg3': lambda: (lambda ds: [(lambda r: int(r) if r == int(r) else r)(sum(ds[i:i+3])/3) for i in range(len(ds)-2)])([int(d) for d in str(abs(int(obj)))]), 'digitWindowProduct3': lambda: (lambda ds: [ds[i]*ds[i+1]*ds[i+2] for i in range(len(ds)-2)])([int(d) for d in str(abs(int(obj)))]), 'digitWindowRange3': lambda: (lambda ds: [max(ds[i:i+3]) - min(ds[i:i+3]) for i in range(len(ds)-2)])([int(d) for d in str(abs(int(obj)))]), 'digitWindowGCD3': lambda: (lambda ds: [__import__('functools').reduce(__import__('math').gcd, ds[i:i+3]) for i in range(len(ds)-2)])([int(d) for d in str(abs(int(obj)))]), 'digitWindowLCM3': lambda: (lambda ds: [__import__('functools').reduce(lambda a, b: a * b // __import__('math').gcd(a, b), ds[i:i+3]) for i in range(len(ds)-2)])([int(d) for d in str(abs(int(obj)))]), 'digitNGrams2': lambda: (lambda s: [int(s[i:i+2]) for i in range(len(s)-1)])(str(abs(int(obj)))), 'digitNGrams3': lambda: (lambda s: [int(s[i:i+3]) for i in range(len(s)-2)])(str(abs(int(obj)))), 'digitConvolutions': lambda: (lambda ds: [sum(ds[j]*ds[k-j] for j in range(max(0,k-len(ds)+1), min(k,len(ds)-1)+1)) for k in range(2*len(ds)-1)])([int(d) for d in str(abs(int(obj)))]), 'digitZeroPad': lambda: (lambda ds: [0] + ds if len(ds) % 2 != 0 else ds)([int(d) for d in str(abs(int(obj)))]), 'digitEvenPositions': lambda: (lambda ds: [ds[i] for i in range(0, len(ds), 2)])([int(d) for d in str(abs(int(obj)))]), 'digitOddPositions': lambda: (lambda ds: [ds[i] for i in range(1, len(ds), 2)])([int(d) for d in str(abs(int(obj)))]), 'digitReverseSlice': lambda: [int(d) for d in str(abs(int(obj)))][::-1], 'digitSortAsc': lambda: sorted([int(d) for d in str(abs(int(obj)))]), 'digitUniqueCount': lambda: len(set(str(abs(int(obj))))), 'digitUniqueValues': lambda: sorted(set(int(d) for d in str(abs(int(obj))))), 'digitFrequencyMap': lambda: {int(d): str(abs(int(obj))).count(d) for d in sorted(set(str(abs(int(obj)))))}, 'digitInterleave': lambda: (lambda ds: [ds[i//2] if i % 2 == 0 else ds[-(i//2)-1] for i in range(len(ds))])([int(d) for d in str(abs(int(obj)))]), 'digitPairSum': lambda: (lambda ds: [ds[i] + ds[i+1] if i+1 < len(ds) else ds[i] for i in range(0, len(ds), 2)])([int(d) for d in str(abs(int(obj)))]), 'digitPairProduct': lambda: (lambda ds: [ds[i] * ds[i+1] if i+1 < len(ds) else ds[i] for i in range(0, len(ds), 2)])([int(d) for d in str(abs(int(obj)))]), 'digitPairMax': lambda: (lambda ds: [max(ds[i], ds[i+1]) if i+1 < len(ds) else ds[i] for i in range(0, len(ds), 2)])([int(d) for d in str(abs(int(obj)))]), 'digitPairMin': lambda: (lambda ds: [min(ds[i], ds[i+1]) if i+1 < len(ds) else ds[i] for i in range(0, len(ds), 2)])([int(d) for d in str(abs(int(obj)))]), 'digitPairDiff': lambda: (lambda ds: [abs(ds[i] - ds[i+1]) if i+1 < len(ds) else ds[i] for i in range(0, len(ds), 2)])([int(d) for d in str(abs(int(obj)))]), 'digitPairGCD': lambda: (lambda ds: [__import__('math').gcd(ds[i], ds[i+1]) if i+1 < len(ds) else ds[i] for i in range(0, len(ds), 2)])([int(d) for d in str(abs(int(obj)))]), 'digitPairLCM': lambda: (lambda ds: [ds[i] * ds[i+1] // __import__('math').gcd(ds[i], ds[i+1]) if i+1 < len(ds) and ds[i] and ds[i+1] else (ds[i] if i+1 >= len(ds) else 0) for i in range(0, len(ds), 2)])([int(d) for d in str(abs(int(obj)))]), 'digitPairAvg': lambda: (lambda ds: [(lambda r: int(r) if r == int(r) else r)((ds[i]+ds[i+1])/2) if i+1 < len(ds) else ds[i] for i in range(0, len(ds), 2)])([int(d) for d in str(abs(int(obj)))]), 'digitPairModulo': lambda: (lambda ds: [ds[i] % ds[i+1] if i+1 < len(ds) and ds[i+1] != 0 else (ds[i] if i+1 >= len(ds) else 0) for i in range(0, len(ds), 2)])([int(d) for d in str(abs(int(obj)))]), 'digitPairPower': lambda: (lambda ds: [ds[i] ** ds[i+1] if i+1 < len(ds) else ds[i] for i in range(0, len(ds), 2)])([int(d) for d in str(abs(int(obj)))]), 'digitTripleSum': lambda: (lambda ds: [sum(ds[i:i+3]) for i in range(0, len(ds), 3)])([int(d) for d in str(abs(int(obj)))]), 'digitTripleProduct': lambda: (lambda ds: [__import__('functools').reduce(lambda a, b: a * b, ds[i:i+3]) for i in range(0, len(ds), 3)])([int(d) for d in str(abs(int(obj)))]), 'digitTripleMax': lambda: (lambda ds: [max(ds[i:i+3]) for i in range(0, len(ds), 3)])([int(d) for d in str(abs(int(obj)))]), 'digitTripleMin': lambda: (lambda ds: [min(ds[i:i+3]) for i in range(0, len(ds), 3)])([int(d) for d in str(abs(int(obj)))]), 'digitTripleAvg': lambda: (lambda ds: [(lambda r: int(r) if r == int(r) else r)(sum(ds[i:i+3])/len(ds[i:i+3])) for i in range(0, len(ds), 3)])([int(d) for d in str(abs(int(obj)))]), 'digitTripleGCD': lambda: (lambda ds: [__import__('functools').reduce(__import__('math').gcd, ds[i:i+3]) for i in range(0, len(ds), 3)])([int(d) for d in str(abs(int(obj)))]), 'digitTripleLCM': lambda: (lambda ds: [__import__('functools').reduce(lambda a, b: a * b // __import__('math').gcd(a, b) if a and b else 0, ds[i:i+3]) for i in range(0, len(ds), 3)])([int(d) for d in str(abs(int(obj)))]), 'digitQuadSum': lambda: (lambda ds: [sum(ds[i:i+4]) for i in range(0, len(ds), 4)])([int(d) for d in str(abs(int(obj)))]), 'digitQuadProduct': lambda: (lambda ds: [__import__('functools').reduce(lambda a, b: a * b, ds[i:i+4]) for i in range(0, len(ds), 4)])([int(d) for d in str(abs(int(obj)))]), 'digitQuadMax': lambda: (lambda ds: [max(ds[i:i+4]) for i in range(0, len(ds), 4)])([int(d) for d in str(abs(int(obj)))]), 'digitQuadMin': lambda: (lambda ds: [min(ds[i:i+4]) for i in range(0, len(ds), 4)])([int(d) for d in str(abs(int(obj)))]), 'digitQuadAvg': lambda: (lambda ds: [(lambda r: int(r) if r == int(r) else r)(sum(ds[i:i+4])/len(ds[i:i+4])) for i in range(0, len(ds), 4)])([int(d) for d in str(abs(int(obj)))]), 'digitQuadGCD': lambda: (lambda ds: [__import__('functools').reduce(__import__('math').gcd, ds[i:i+4]) for i in range(0, len(ds), 4)])([int(d) for d in str(abs(int(obj)))]), 'digitQuadLCM': lambda: (lambda ds: [__import__('functools').reduce(lambda a, b: a * b // __import__('math').gcd(a, b) if a and b else 0, ds[i:i+4]) for i in range(0, len(ds), 4)])([int(d) for d in str(abs(int(obj)))]), 'digitQuintSum': lambda: (lambda ds: [sum(ds[i:i+5]) for i in range(0, len(ds), 5)])([int(d) for d in str(abs(int(obj)))]), 'digitQuintProduct': lambda: (lambda ds: [__import__('functools').reduce(lambda a, b: a * b, ds[i:i+5]) for i in range(0, len(ds), 5)])([int(d) for d in str(abs(int(obj)))]), 'digitQuintMax': lambda: (lambda ds: [max(ds[i:i+5]) for i in range(0, len(ds), 5)])([int(d) for d in str(abs(int(obj)))]), 'digitQuintMin': lambda: (lambda ds: [min(ds[i:i+5]) for i in range(0, len(ds), 5)])([int(d) for d in str(abs(int(obj)))]), 'digitQuintAvg': lambda: (lambda ds: [(lambda r: int(r) if r == int(r) else r)(sum(ds[i:i+5])/len(ds[i:i+5])) for i in range(0, len(ds), 5)])([int(d) for d in str(abs(int(obj)))]), 'digitQuintGCD': lambda: (lambda ds: [__import__('functools').reduce(__import__('math').gcd, ds[i:i+5]) for i in range(0, len(ds), 5)])([int(d) for d in str(abs(int(obj)))]), 'digitQuintLCM': lambda: (lambda ds: [__import__('functools').reduce(lambda a, b: a * b // __import__('math').gcd(a, b) if a and b else 0, ds[i:i+5]) for i in range(0, len(ds), 5)])([int(d) for d in str(abs(int(obj)))]), 'digitSextSum': lambda: (lambda ds: [sum(ds[i:i+6]) for i in range(0, len(ds), 6)])([int(d) for d in str(abs(int(obj)))]), 'digitSextProduct': lambda: (lambda ds: [__import__('functools').reduce(lambda a, b: a * b, ds[i:i+6]) for i in range(0, len(ds), 6)])([int(d) for d in str(abs(int(obj)))]), 'digitSextMax': lambda: (lambda ds: [max(ds[i:i+6]) for i in range(0, len(ds), 6)])([int(d) for d in str(abs(int(obj)))]), 'digitSextMin': lambda: (lambda ds: [min(ds[i:i+6]) for i in range(0, len(ds), 6)])([int(d) for d in str(abs(int(obj)))]), 'digitSextAvg': lambda: (lambda ds: [(lambda r: int(r) if r == int(r) else r)(sum(ds[i:i+6])/len(ds[i:i+6])) for i in range(0, len(ds), 6)])([int(d) for d in str(abs(int(obj)))]), 'digitSextGCD': lambda: (lambda ds: [__import__('functools').reduce(__import__('math').gcd, ds[i:i+6]) for i in range(0, len(ds), 6)])([int(d) for d in str(abs(int(obj)))]), 'digitSextLCM': lambda: (lambda ds: [__import__('functools').reduce(lambda a, b: a * b // __import__('math').gcd(a, b) if a and b else 0, ds[i:i+6]) for i in range(0, len(ds), 6)])([int(d) for d in str(abs(int(obj)))]), 'digitSeptSum': lambda: (lambda ds: [sum(ds[i:i+7]) for i in range(0, len(ds), 7)])([int(d) for d in str(abs(int(obj)))]), 'digitSeptProduct': lambda: (lambda ds: [__import__('functools').reduce(lambda a, b: a * b, ds[i:i+7]) for i in range(0, len(ds), 7)])([int(d) for d in str(abs(int(obj)))]), 'digitSeptMax': lambda: (lambda ds: [max(ds[i:i+7]) for i in range(0, len(ds), 7)])([int(d) for d in str(abs(int(obj)))]), 'digitSeptMin': lambda: (lambda ds: [min(ds[i:i+7]) for i in range(0, len(ds), 7)])([int(d) for d in str(abs(int(obj)))]), 'digitSeptAvg': lambda: (lambda ds: [(lambda r: int(r) if r == int(r) else r)(sum(ds[i:i+7])/len(ds[i:i+7])) for i in range(0, len(ds), 7)])([int(d) for d in str(abs(int(obj)))]), 'digitSeptGCD': lambda: (lambda ds: [__import__('functools').reduce(__import__('math').gcd, ds[i:i+7]) for i in range(0, len(ds), 7)])([int(d) for d in str(abs(int(obj)))]), 'digitSeptLCM': lambda: (lambda ds: [__import__('functools').reduce(lambda a, b: a * b // __import__('math').gcd(a, b) if a and b else 0, ds[i:i+7]) for i in range(0, len(ds), 7)])([int(d) for d in str(abs(int(obj)))]), 'digitOctSum': lambda: (lambda ds: [sum(ds[i:i+8]) for i in range(0, len(ds), 8)])([int(d) for d in str(abs(int(obj)))]), 'digitOctProduct': lambda: (lambda ds: [__import__('functools').reduce(lambda a, b: a * b, ds[i:i+8]) for i in range(0, len(ds), 8)])([int(d) for d in str(abs(int(obj)))]), 'digitOctMax': lambda: (lambda ds: [max(ds[i:i+8]) for i in range(0, len(ds), 8)])([int(d) for d in str(abs(int(obj)))]), 'digitOctMin': lambda: (lambda ds: [min(ds[i:i+8]) for i in range(0, len(ds), 8)])([int(d) for d in str(abs(int(obj)))]), 'digitOctAvg': lambda: (lambda ds: [(lambda r: int(r) if r == int(r) else r)(sum(ds[i:i+8])/len(ds[i:i+8])) for i in range(0, len(ds), 8)])([int(d) for d in str(abs(int(obj)))]), 'digitOctGCD': lambda: (lambda ds: [__import__('functools').reduce(__import__('math').gcd, ds[i:i+8]) for i in range(0, len(ds), 8)])([int(d) for d in str(abs(int(obj)))]), 'digitOctLCM': lambda: (lambda ds: [__import__('functools').reduce(lambda a, b: a * b // __import__('math').gcd(a, b) if a and b else 0, ds[i:i+8]) for i in range(0, len(ds), 8)])([int(d) for d in str(abs(int(obj)))]), 'digitNonSum': lambda: (lambda ds: [sum(ds[i:i+9]) for i in range(0, len(ds), 9)])([int(d) for d in str(abs(int(obj)))]), 'digitNonProduct': lambda: (lambda ds: [__import__('functools').reduce(lambda a, b: a * b, ds[i:i+9]) for i in range(0, len(ds), 9)])([int(d) for d in str(abs(int(obj)))]), 'digitNonMax': lambda: (lambda ds: [max(ds[i:i+9]) for i in range(0, len(ds), 9)])([int(d) for d in str(abs(int(obj)))]), 'digitNonMin': lambda: (lambda ds: [min(ds[i:i+9]) for i in range(0, len(ds), 9)])([int(d) for d in str(abs(int(obj)))]), 'digitNonAvg': lambda: (lambda ds: [(lambda r: int(r) if r == int(r) else r)(sum(ds[i:i+9])/len(ds[i:i+9])) for i in range(0, len(ds), 9)])([int(d) for d in str(abs(int(obj)))]), 'digitNonGCD': lambda: (lambda ds: [__import__('functools').reduce(__import__('math').gcd, ds[i:i+9]) for i in range(0, len(ds), 9)])([int(d) for d in str(abs(int(obj)))]), 'digitNonLCM': lambda: (lambda ds: [__import__('functools').reduce(lambda a, b: a * b // __import__('math').gcd(a, b) if a and b else 0, ds[i:i+9]) for i in range(0, len(ds), 9)])([int(d) for d in str(abs(int(obj)))]), 'digitDecSum': lambda: (lambda ds: [sum(ds[i:i+10]) for i in range(0, len(ds), 10)])([int(d) for d in str(abs(int(obj)))]), 'digitDecProduct': lambda: (lambda ds: [__import__('functools').reduce(lambda a, b: a * b, ds[i:i+10]) for i in range(0, len(ds), 10)])([int(d) for d in str(abs(int(obj)))]), 'digitDecMax': lambda: (lambda ds: [max(ds[i:i+10]) for i in range(0, len(ds), 10)])([int(d) for d in str(abs(int(obj)))]), 'digitDecMin': lambda: (lambda ds: [min(ds[i:i+10]) for i in range(0, len(ds), 10)])([int(d) for d in str(abs(int(obj)))]), 'digitDecAvg': lambda: (lambda ds: [(lambda r: int(r) if r == int(r) else r)(sum(ds[i:i+10])/len(ds[i:i+10])) for i in range(0, len(ds), 10)])([int(d) for d in str(abs(int(obj)))]), 'digitDecGCD': lambda: (lambda ds: [__import__('functools').reduce(__import__('math').gcd, ds[i:i+10]) for i in range(0, len(ds), 10)])([int(d) for d in str(abs(int(obj)))]), 'digitDecLCM': lambda: (lambda ds: [__import__('functools').reduce(lambda a, b: a * b // __import__('math').gcd(a, b) if a and b else 0, ds[i:i+10]) for i in range(0, len(ds), 10)])([int(d) for d in str(abs(int(obj)))]), 'digitUndecSum': lambda: (lambda ds: [sum(ds[i:i+11]) for i in range(0, len(ds), 11)])([int(d) for d in str(abs(int(obj)))]), 'digitUndecProduct': lambda: (lambda ds: [__import__('functools').reduce(lambda a, b: a * b, ds[i:i+11]) for i in range(0, len(ds), 11)])([int(d) for d in str(abs(int(obj)))]), 'digitUndecMax': lambda: (lambda ds: [max(ds[i:i+11]) for i in range(0, len(ds), 11)])([int(d) for d in str(abs(int(obj)))]), 'digitUndecMin': lambda: (lambda ds: [min(ds[i:i+11]) for i in range(0, len(ds), 11)])([int(d) for d in str(abs(int(obj)))]), 'digitUndecAvg': lambda: (lambda ds: [(lambda r: int(r) if r == int(r) else r)(sum(ds[i:i+11])/len(ds[i:i+11])) for i in range(0, len(ds), 11)])([int(d) for d in str(abs(int(obj)))]), 'digitUndecGCD': lambda: (lambda ds: [__import__('functools').reduce(__import__('math').gcd, ds[i:i+11]) for i in range(0, len(ds), 11)])([int(d) for d in str(abs(int(obj)))]), 'digitUndecLCM': lambda: (lambda ds: [__import__('functools').reduce(lambda a, b: a * b // __import__('math').gcd(a, b) if a and b else 0, ds[i:i+11]) for i in range(0, len(ds), 11)])([int(d) for d in str(abs(int(obj)))]), 'digitDuodecSum': lambda: (lambda ds: [sum(ds[i:i+12]) for i in range(0, len(ds), 12)])([int(d) for d in str(abs(int(obj)))]), 'digitDuodecProduct': lambda: (lambda ds: [__import__('functools').reduce(lambda a, b: a * b, ds[i:i+12]) for i in range(0, len(ds), 12)])([int(d) for d in str(abs(int(obj)))]), 'digitDuodecMax': lambda: (lambda ds: [max(ds[i:i+12]) for i in range(0, len(ds), 12)])([int(d) for d in str(abs(int(obj)))]), 'digitDuodecMin': lambda: (lambda ds: [min(ds[i:i+12]) for i in range(0, len(ds), 12)])([int(d) for d in str(abs(int(obj)))]), 'digitDuodecAvg': lambda: (lambda ds: [(lambda r: int(r) if r == int(r) else r)(sum(ds[i:i+12])/len(ds[i:i+12])) for i in range(0, len(ds), 12)])([int(d) for d in str(abs(int(obj)))]), 'digitDuodecGCD': lambda: (lambda ds: [__import__('functools').reduce(__import__('math').gcd, ds[i:i+12]) for i in range(0, len(ds), 12)])([int(d) for d in str(abs(int(obj)))]), 'digitDuodecLCM': lambda: (lambda ds: [__import__('functools').reduce(lambda a, b: a * b // __import__('math').gcd(a, b) if a and b else 0, ds[i:i+12]) for i in range(0, len(ds), 12)])([int(d) for d in str(abs(int(obj)))]), 'digitTredecSum': lambda: (lambda ds: [sum(ds[i:i+13]) for i in range(0, len(ds), 13)])([int(d) for d in str(abs(int(obj)))]), 'digitTredecProduct': lambda: (lambda ds: [__import__('functools').reduce(lambda a, b: a * b, ds[i:i+13]) for i in range(0, len(ds), 13)])([int(d) for d in str(abs(int(obj)))]), 'digitTredecMax': lambda: (lambda ds: [max(ds[i:i+13]) for i in range(0, len(ds), 13)])([int(d) for d in str(abs(int(obj)))]), 'digitTredecMin': lambda: (lambda ds: [min(ds[i:i+13]) for i in range(0, len(ds), 13)])([int(d) for d in str(abs(int(obj)))]), 'digitTredecAvg': lambda: (lambda ds: [(lambda r: int(r) if r == int(r) else r)(sum(ds[i:i+13])/len(ds[i:i+13])) for i in range(0, len(ds), 13)])([int(d) for d in str(abs(int(obj)))]), 'digitTredecGCD': lambda: (lambda ds: [__import__('functools').reduce(__import__('math').gcd, ds[i:i+13]) for i in range(0, len(ds), 13)])([int(d) for d in str(abs(int(obj)))]), 'digitTredecLCM': lambda: (lambda ds: [__import__('functools').reduce(lambda a, b: a * b // __import__('math').gcd(a, b) if a and b else 0, ds[i:i+13]) for i in range(0, len(ds), 13)])([int(d) for d in str(abs(int(obj)))]), 'digitQuattuordecSum': lambda: (lambda ds: [sum(ds[i:i+14]) for i in range(0, len(ds), 14)])([int(d) for d in str(abs(int(obj)))]), 'digitQuattuordecProduct': lambda: (lambda ds: [__import__('functools').reduce(lambda a, b: a * b, ds[i:i+14]) for i in range(0, len(ds), 14)])([int(d) for d in str(abs(int(obj)))]), 'digitQuattuordecMax': lambda: (lambda ds: [max(ds[i:i+14]) for i in range(0, len(ds), 14)])([int(d) for d in str(abs(int(obj)))]), 'digitQuattuordecMin': lambda: (lambda ds: [min(ds[i:i+14]) for i in range(0, len(ds), 14)])([int(d) for d in str(abs(int(obj)))]), 'digitQuattuordecAvg': lambda: (lambda ds: [(lambda r: int(r) if r == int(r) else r)(sum(ds[i:i+14])/len(ds[i:i+14])) for i in range(0, len(ds), 14)])([int(d) for d in str(abs(int(obj)))]), 'digitQuattuordecGCD': lambda: (lambda ds: [__import__('functools').reduce(__import__('math').gcd, ds[i:i+14]) for i in range(0, len(ds), 14)])([int(d) for d in str(abs(int(obj)))]), 'digitQuattuordecLCM': lambda: (lambda ds: [__import__('functools').reduce(lambda a, b: a * b // __import__('math').gcd(a, b) if a and b else 0, ds[i:i+14]) for i in range(0, len(ds), 14)])([int(d) for d in str(abs(int(obj)))]), 'digitQuindecSum': lambda: (lambda ds: [sum(ds[i:i+15]) for i in range(0, len(ds), 15)])([int(d) for d in str(abs(int(obj)))]), 'digitQuindecProduct': lambda: (lambda ds: [__import__('functools').reduce(lambda a, b: a * b, ds[i:i+15]) for i in range(0, len(ds), 15)])([int(d) for d in str(abs(int(obj)))]), 'digitQuindecMax': lambda: (lambda ds: [max(ds[i:i+15]) for i in range(0, len(ds), 15)])([int(d) for d in str(abs(int(obj)))]), 'digitQuindecMin': lambda: (lambda ds: [min(ds[i:i+15]) for i in range(0, len(ds), 15)])([int(d) for d in str(abs(int(obj)))]), 'digitQuindecAvg': lambda: (lambda ds: [(lambda r: int(r) if r == int(r) else r)(sum(ds[i:i+15])/len(ds[i:i+15])) for i in range(0, len(ds), 15)])([int(d) for d in str(abs(int(obj)))]), 'digitQuindecGCD': lambda: (lambda ds: [__import__('functools').reduce(__import__('math').gcd, ds[i:i+15]) for i in range(0, len(ds), 15)])([int(d) for d in str(abs(int(obj)))]), 'digitQuindecLCM': lambda: (lambda ds: [__import__('functools').reduce(lambda a, b: a * b // __import__('math').gcd(a, b), ds[i:i+15]) for i in range(0, len(ds), 15)])([int(d) for d in str(abs(int(obj)))]), 'digitSedecSum': lambda: (lambda ds: [sum(ds[i:i+16]) for i in range(0, len(ds), 16)])([int(d) for d in str(abs(int(obj)))]), 'digitSedecProduct': lambda: (lambda ds: [__import__('functools').reduce(lambda a, b: a * b, ds[i:i+16]) for i in range(0, len(ds), 16)])([int(d) for d in str(abs(int(obj)))]), 'digitSedecMax': lambda: (lambda ds: [max(ds[i:i+16]) for i in range(0, len(ds), 16)])([int(d) for d in str(abs(int(obj)))]), 'digitSedecMin': lambda: (lambda ds: [min(ds[i:i+16]) for i in range(0, len(ds), 16)])([int(d) for d in str(abs(int(obj)))]), 'digitSedecAvg': lambda: (lambda ds: [sum(ds[i:i+16]) / len(ds[i:i+16]) for i in range(0, len(ds), 16)])([int(d) for d in str(abs(int(obj)))]), 'digitSedecGCD': lambda: (lambda ds: [__import__('functools').reduce(__import__('math').gcd, ds[i:i+16]) for i in range(0, len(ds), 16)])([int(d) for d in str(abs(int(obj)))]), 'digitSedecLCM': lambda: (lambda ds: [__import__('functools').reduce(lambda a, b: a * b // __import__('math').gcd(a, b), ds[i:i+16]) for i in range(0, len(ds), 16)])([int(d) for d in str(abs(int(obj)))]), 'digitSeptendecSum': lambda: (lambda ds: [sum(ds[i:i+17]) for i in range(0, len(ds), 17)])([int(d) for d in str(abs(int(obj)))]), 'digitSeptendecProduct': lambda: (lambda ds: [__import__('functools').reduce(lambda a, b: a * b, ds[i:i+17]) for i in range(0, len(ds), 17)])([int(d) for d in str(abs(int(obj)))]), 'digitSeptendecMax': lambda: (lambda ds: [max(ds[i:i+17]) for i in range(0, len(ds), 17)])([int(d) for d in str(abs(int(obj)))]), 'digitSeptendecMin': lambda: (lambda ds: [min(ds[i:i+17]) for i in range(0, len(ds), 17)])([int(d) for d in str(abs(int(obj)))]), 'digitSeptendecAvg': lambda: (lambda ds: [sum(ds[i:i+17]) / len(ds[i:i+17]) for i in range(0, len(ds), 17)])([int(d) for d in str(abs(int(obj)))]), 'digitSeptendecGCD': lambda: (lambda ds: [__import__('functools').reduce(__import__('math').gcd, ds[i:i+17]) for i in range(0, len(ds), 17)])([int(d) for d in str(abs(int(obj)))]), 'digitSeptendecLCM': lambda: (lambda ds: [__import__('functools').reduce(lambda a, b: a * b // __import__('math').gcd(a, b), ds[i:i+17]) for i in range(0, len(ds), 17)])([int(d) for d in str(abs(int(obj)))]), 'digitOctodecSum': lambda: (lambda ds: [sum(ds[i:i+18]) for i in range(0, len(ds), 18)])([int(d) for d in str(abs(int(obj)))]), 'digitOctodecProduct': lambda: (lambda ds: [__import__('functools').reduce(lambda a, b: a * b, ds[i:i+18]) for i in range(0, len(ds), 18)])([int(d) for d in str(abs(int(obj)))]), 'digitOctodecMax': lambda: (lambda ds: [max(ds[i:i+18]) for i in range(0, len(ds), 18)])([int(d) for d in str(abs(int(obj)))]), 'digitOctodecMin': lambda: (lambda ds: [min(ds[i:i+18]) for i in range(0, len(ds), 18)])([int(d) for d in str(abs(int(obj)))]), 'digitOctodecAvg': lambda: (lambda ds: [sum(ds[i:i+18]) / len(ds[i:i+18]) for i in range(0, len(ds), 18)])([int(d) for d in str(abs(int(obj)))]), 'digitOctodecGCD': lambda: (lambda ds: [__import__('functools').reduce(__import__('math').gcd, ds[i:i+18]) for i in range(0, len(ds), 18)])([int(d) for d in str(abs(int(obj)))]), 'digitOctodecLCM': lambda: (lambda ds: [__import__('functools').reduce(lambda a, b: a * b // __import__('math').gcd(a, b), ds[i:i+18]) for i in range(0, len(ds), 18)])([int(d) for d in str(abs(int(obj)))]), 'digitNovemdecSum': lambda: (lambda ds: [sum(ds[i:i+19]) for i in range(0, len(ds), 19)])([int(d) for d in str(abs(int(obj)))]), 'digitNovemdecProduct': lambda: (lambda ds: [__import__('functools').reduce(lambda a, b: a * b, ds[i:i+19]) for i in range(0, len(ds), 19)])([int(d) for d in str(abs(int(obj)))]), 'digitNovemdecMax': lambda: (lambda ds: [max(ds[i:i+19]) for i in range(0, len(ds), 19)])([int(d) for d in str(abs(int(obj)))]), 'digitNovemdecMin': lambda: (lambda ds: [min(ds[i:i+19]) for i in range(0, len(ds), 19)])([int(d) for d in str(abs(int(obj)))]), 'digitNovemdecAvg': lambda: (lambda ds: [sum(ds[i:i+19]) / len(ds[i:i+19]) for i in range(0, len(ds), 19)])([int(d) for d in str(abs(int(obj)))]), 'digitNovemdecGCD': lambda: (lambda ds: [__import__('functools').reduce(__import__('math').gcd, ds[i:i+19]) for i in range(0, len(ds), 19)])([int(d) for d in str(abs(int(obj)))]), 'digitNovemdecLCM': lambda: (lambda ds: [__import__('functools').reduce(lambda a, b: a * b // __import__('math').gcd(a, b), ds[i:i+19]) for i in range(0, len(ds), 19)])([int(d) for d in str(abs(int(obj)))]), 'digitVigintSum': lambda: (lambda ds: [sum(ds[i:i+20]) for i in range(0, len(ds), 20)])([int(d) for d in str(abs(int(obj)))]), 'digitVigintProduct': lambda: (lambda ds: [__import__('functools').reduce(lambda a, b: a * b, ds[i:i+20]) for i in range(0, len(ds), 20)])([int(d) for d in str(abs(int(obj)))]), 'digitVigintMax': lambda: (lambda ds: [max(ds[i:i+20]) for i in range(0, len(ds), 20)])([int(d) for d in str(abs(int(obj)))]), 'digitVigintMin': lambda: (lambda ds: [min(ds[i:i+20]) for i in range(0, len(ds), 20)])([int(d) for d in str(abs(int(obj)))]), 'digitVigintAvg': lambda: (lambda ds: [(lambda r: int(r) if r == int(r) else r)(sum(ds[i:i+20])/len(ds[i:i+20])) for i in range(0, len(ds), 20)])([int(d) for d in str(abs(int(obj)))]), 'digitVigintGCD': lambda: (lambda ds: [__import__('functools').reduce(__import__('math').gcd, ds[i:i+20]) for i in range(0, len(ds), 20)])([int(d) for d in str(abs(int(obj)))]), 'digitVigintLCM': lambda: (lambda ds: [__import__('functools').reduce(lambda a, b: a * b // __import__('math').gcd(a, b), ds[i:i+20]) for i in range(0, len(ds), 20)])([int(d) for d in str(abs(int(obj)))]), 'digitUnvigintSum': lambda: (lambda ds: [sum(ds[i:i+21]) for i in range(0, len(ds), 21)])([int(d) for d in str(abs(int(obj)))]), 'digitUnvigintProduct': lambda: (lambda ds: [__import__('functools').reduce(lambda a, b: a * b, ds[i:i+21]) for i in range(0, len(ds), 21)])([int(d) for d in str(abs(int(obj)))]), 'digitUnvigintMax': lambda: (lambda ds: [max(ds[i:i+21]) for i in range(0, len(ds), 21)])([int(d) for d in str(abs(int(obj)))]), 'digitUnvigintMin': lambda: (lambda ds: [min(ds[i:i+21]) for i in range(0, len(ds), 21)])([int(d) for d in str(abs(int(obj)))]), 'digitUnvigintAvg': lambda: (lambda ds: [(lambda r: int(r) if r == int(r) else r)(sum(ds[i:i+21])/len(ds[i:i+21])) for i in range(0, len(ds), 21)])([int(d) for d in str(abs(int(obj)))]), 'digitUnvigintGCD': lambda: (lambda ds: [__import__('functools').reduce(__import__('math').gcd, ds[i:i+21]) for i in range(0, len(ds), 21)])([int(d) for d in str(abs(int(obj)))]),
        }
        if member == 'isEconomical': member = 'isFrugal'
        if member in _simple:
            fn = _simple[member]
            return ('builtin', lambda args, ctx: fn())
        _onearg = {
            'clampMin': lambda a: max(obj, a[0]), 'clampMax': lambda a: min(obj, a[0]),
            'toFixed': lambda a: f"{obj:.{int(a[0])}f}", 'pow': lambda a: obj ** int(a[0]),
            'gcd': lambda a: math.gcd(int(obj), int(a[0])), 'lcm': lambda a: abs(int(obj) * int(a[0])) // math.gcd(int(obj), int(a[0])),
            'clamp': lambda a: max(a[0], min(obj, a[1])),
            'isBetween': lambda a: a[0] <= obj <= a[1],
            'toBase': lambda a: _to_base(int(obj), int(a[0])),
            'toBinaryString': lambda a: bin(int(obj))[2:].zfill(int(a[0])),
            'isCoprime': lambda a: math.gcd(int(obj), int(a[0])) == 1,
            'toBinaryArray': lambda a: [int(b) for b in bin(int(obj))[2:].zfill(int(a[0]))],
            'nthRoot': lambda a: (lambda r: int(r) if r == int(r) else r)(round(obj ** (1/a[0]), 10)),
            'isLychrel': lambda a: (f := lambda n, i: True if i <= 0 else (lambda r: False if str(r) == str(r)[::-1] else f(r, i-1))(n + int(str(n)[::-1])))(int(obj), int(a[0])),
            'sumOfDigitsPower': lambda a: sum(int(d) ** int(a[0]) for d in str(abs(int(obj)))),
            'stirling': lambda a: (lambda n, k: sum((-1)**(k-j) * math.comb(k, j) * j**n for j in range(k+1)) // math.factorial(k))(int(obj), int(a[0])),
            'centered': lambda a: int(a[0]) * int(obj) * (int(obj) - 1) // 2 + 1,
            'polygonal': lambda a: int(obj) * ((int(a[0]) - 2) * int(obj) - (int(a[0]) - 4)) // 2, 'nthDigit': lambda a: int(str(abs(int(obj)))[int(a[0])]), 'digitAt': lambda a: int(str(abs(int(obj)))[::-1][int(a[0])]), 'rotateDigits': lambda a: (lambda s, n: int(s[n:] + s[:n]))(str(int(obj)), int(a[0]) % len(str(int(obj)))), 'truncateDigits': lambda a: int(str(int(obj))[:int(a[0])]), 'padDigits': lambda a: str(int(obj)).zfill(int(a[0])), 'digitHeadN': lambda a: [int(d) for d in str(abs(int(obj)))][:int(a[0])], 'digitTailN': lambda a: [int(d) for d in str(abs(int(obj)))][-int(a[0]):], 'digitSliceN': lambda a: [int(d) for d in str(abs(int(obj)))][int(a[0]):int(a[1])],
            'isSmooth': lambda a: (lambda n, k: (lambda f: f(f, n, 2))((lambda f, n, d: n <= 1 if d > k else f(f, n // d, d) if n % d == 0 else f(f, n, d + 1))))(int(obj), int(a[0])),
            'isRough': lambda a: (lambda n, k: all(n % d != 0 for d in range(2, min(k, n))))(int(obj), int(a[0])),
            'isAlmostPrime': lambda a: (lambda n, k: (lambda f: f(f, n, 2, 0))((lambda f, n, d, c: c == k if n <= 1 else f(f, n//d, d, c+1) if n % d == 0 else f(f, n, d+1, c))))(int(obj), int(a[0])),
            'isHarshadInBase': lambda a: (lambda n, b: n > 0 and n % sum((lambda f: f(f, n, b))((lambda f, n, b: [n % b] + f(f, n // b, b) if n > 0 else []))) == 0)(int(obj), int(a[0])),
            'isPronicInRange': lambda a: (lambda n, mx: n <= mx and (lambda k: k * (k + 1) == n)(int(n ** 0.5)))(int(obj), int(a[0])),
            'isPalindromeInBase': lambda a: (lambda n, b: (lambda s: s == s[::-1])((lambda f: f(f, n, b, ''))((lambda f, n, b, r: r or '0' if n == 0 else f(f, n // b, b, chr(n % b + (48 if n % b < 10 else 87)) + r)))))(int(obj), int(a[0])),
            'primesBetween': lambda a: [p for p in range(int(obj), int(a[0])+1) if p >= 2 and all(p % i for i in range(2, int(p**0.5)+1))], 'digitContainsDigit': lambda a: str(int(a[0])) in str(abs(int(obj))), 'digitFirstN': lambda a: int(str(abs(int(obj)))[:int(a[0])]), 'digitLastN': lambda a: int(str(abs(int(obj)))[-int(a[0]):]),
        }
        if member in _onearg:
            fn = _onearg[member]
            return ('builtin', lambda args, ctx: fn(args))
        if member == 'lerp': return ('builtin', lambda args, ctx: (lambda r: int(r) if r == int(r) else r)(obj + (args[0] - obj) * args[1]))
        if member == 'map': return ('builtin', lambda args, ctx: self._call_function(args[0], [obj]))
        if member in ('percent', 'percentOf'): return ('builtin', lambda args, ctx: (lambda r: int(r) if r == int(r) else r)((obj / 100) if member == 'percent' else (obj * args[0] / 100)))
        if member == 'toPercent': return ('builtin', lambda args, ctx: f"{int(v) if (v := round(obj * 100, 10)) == int(v) else v}%")
        if member == 'toOrdinal': return ('builtin', lambda args, ctx: (lambda n: f"{n}{'th' if 11 <= n % 100 <= 13 else ['th','st','nd','rd'][n % 10] if n % 10 < 4 else 'th'}")(int(obj)))
        if member == 'isPrime': return ('builtin', lambda args, ctx: int(obj) >= 2 and all(int(obj) % i for i in range(2, int(int(obj)**0.5) + 1)))
        if member == 'toRoman': return ('builtin', lambda args, ctx: __import__('functools').reduce(lambda nr, vs: (nr[0] % vs[0], nr[1] + vs[1] * (nr[0] // vs[0])), [(1000,'M'),(900,'CM'),(500,'D'),(400,'CD'),(100,'C'),(90,'XC'),(50,'L'),(40,'XL'),(10,'X'),(9,'IX'),(5,'V'),(4,'IV'),(1,'I')], (int(obj), ''))[1])
        if member in ('fibonacci', 'lucasNumber', 'lucas', 'tribonacci', 'jacobsthal', 'pell'):
            def _fib(args, ctx):
                _m = 'lucasNumber' if member == 'lucas' else member
                if _m == 'tribonacci':
                    a, b, c = 0, 1, 1
                    for _ in range(int(obj)): a, b, c = b, c, a + b + c
                    return a
                a, b = {'fibonacci': (0, 1), 'lucasNumber': (2, 1), 'jacobsthal': (0, 1), 'pell': (0, 1)}[_m]
                for _ in range(int(obj)): a, b = b, ({'jacobsthal': b + 2*a, 'pell': 2*b + a}.get(_m, a + b))
                return a
            return ('builtin', _fib)
        if member == 'toWords':
            def _tw(args, ctx, _o=['','one','two','three','four','five','six','seven','eight','nine','ten','eleven','twelve','thirteen','fourteen','fifteen','sixteen','seventeen','eighteen','nineteen'], _t=['','','twenty','thirty','forty','fifty','sixty','seventy','eighty','ninety']):
                n = int(obj)
                if n == 0: return 'zero'
                _ch = lambda num: '' if num == 0 else _o[num] if num < 20 else (_t[num // 10] + ('-' + _o[num % 10] if num % 10 else '')) if num < 100 else _o[num // 100] + ' hundred' + (' ' + _ch(num % 100) if num % 100 else '')
                p, s, rem = [], ['', ' thousand', ' million', ' billion'], abs(n)
                while rem > 0: (p.append(_ch(rem % 1000) + s[len(p)]) if rem % 1000 else None); rem //= 1000
                return ('negative ' if n < 0 else '') + ' '.join(reversed(p))
            return ('builtin', _tw)
        if member in ('collatz', 'collatzLength', 'collatzSequence'):
            def _cz(args, ctx):
                n, r = int(obj), [int(obj)]
                while n != 1: n = n // 2 if n % 2 == 0 else 3 * n + 1; r.append(n)
                return r if member == 'collatzSequence' else len(r) - 1
            return ('builtin', _cz)
        if member == 'nthPrime':
            def _np(args, ctx):
                c, p = 0, 1
                while c < int(obj): p += 1; c += all(p % i for i in range(2, int(p**0.5) + 1))
                return p
            return ('builtin', _np)
        if member == 'isHappy': return ('builtin', lambda args, ctx: (f := lambda n, s: True if n == 1 else False if n in s else f(sum(int(d)**2 for d in str(n)), s | {n}))(int(obj), set()))
        if member == 'toFraction':
            from fractions import Fraction as _F
            return ('builtin', lambda args, ctx: str(_F(obj).limit_denominator()))
        if member == 'toCurrency':
            return ('builtin', lambda args, ctx: f"${obj:,.2f}")
        if member == 'isAmicable':
            return ('builtin', lambda args, ctx: (lambda _ds, n: (lambda b: b != n and _ds(b) == n)(_ds(n)) if len(args) == 0 else (lambda a, b: a != b and _ds(a) == b and _ds(b) == a)(n, int(args[0])))(lambda n: sum(i for i in range(1, n) if n % i == 0), int(obj)))
        if member in ('primeFactors', 'primeFactorization'): return ('builtin', lambda args, ctx: (f := lambda n, d: [] if n <= 1 else [d] + f(n//d, d) if n % d == 0 else f(n, d+1))(int(obj), 2))
        if member in ('prevPrime', 'nextPrime'):
            def _pnp(args, ctx, d=(-1 if member == 'prevPrime' else 1)):
                n = int(obj) + d
                while n >= 2 and not all(n % i for i in range(2, int(n**0.5) + 1)): n += d
                return n if n >= 2 else None
            return ('builtin', _pnp)
        if member == 'asTime': return ('builtin', lambda args, ctx: (lambda n, h, m, s: f"{h}:{m:02d}:{s:02d}" if h else f"{m}:{s:02d}")(int(obj), int(obj) // 3600, (int(obj) % 3600) // 60, int(obj) % 60))
        if member in ('isStrongPrime', 'isWeakPrime', 'isBalancedPrime'): return ('builtin', lambda args, ctx: (lambda n, ip, np, pp, avg: ip(n) and (n > avg if member == 'isStrongPrime' else n < avg if member == 'isWeakPrime' else n * 2 == pp(n) + np(n)))(int(obj), lambda n: n >= 2 and all(n % i for i in range(2, int(n**0.5)+1)), lambda n: next(p for p in range(n+1, n*2) if all(p % i for i in range(2, int(p**0.5)+1))), lambda n: next(p for p in range(n-1, 1, -1) if all(p % i for i in range(2, int(p**0.5)+1))), (lambda pp, np: (pp(int(obj)) + np(int(obj))) / 2)(lambda n: next(p for p in range(n-1, 1, -1) if all(p % i for i in range(2, int(p**0.5)+1))), lambda n: next(p for p in range(n+1, n*2) if all(p % i for i in range(2, int(p**0.5)+1))))))
        raise RuntimeError_(f"'number' has no member '{member}'")

    def _eval_method(self, obj: Any, method: str, args: list, env: 'Environment | None' = None) -> Any:
        """Evaluate method call."""
        member = self._eval_member(obj, method, env)
        if isinstance(member, tuple) and member[0] == 'builtin':
            context = {'output_lines': self.output_lines}
            return member[1](args, context)
        if isinstance(member, tuple) and member[0] == 'bound_method':
            _, func, self_obj = member
            return self._call_function(func, [self_obj] + args)
        if isinstance(member, tuple) and member[0] == 'function':
            return self._call_function(member, args)
        return member
